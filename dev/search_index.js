var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"This page provides a plain list of all inline documention associated with functions, structs  and macros in DFControl. Note that this list is neither structured, complete nor particularly clean, so it only provides rough orientation at the moment. The best reference is the code itself.","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [DFControl]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"api/#DFControl.ELEMENTS","page":"API reference","title":"DFControl.ELEMENTS","text":"Reads all the elements from the file.\n\n\n\n\n\n","category":"constant"},{"location":"api/#DFControl.DFBand","page":"API reference","title":"DFControl.DFBand","text":"Energy band from DFT calculation.\n\n\n\n\n\n","category":"type"},{"location":"api/#DFControl.DFInput-Tuple{DFInput, Any, Vararg{Any, N} where N}","page":"API reference","title":"DFControl.DFInput","text":"DFInput(template::DFInput, name::AbstractString, flags::Pair{Symbol}...; excs=deepcopy(execs(template)), run=true, data=nothing, dir=copy(template.dir))\n\nCreates a new DFInput from a template DFInput, setting the newflags in the new one.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.DFInput-Union{Tuple{P}, Tuple{AbstractString, Vector{Exec}, Vararg{Pair{Symbol, B} where B, N} where N}} where P<:DFControl.Package","page":"API reference","title":"DFControl.DFInput","text":"DFInput{P}(name::AbstractString, execs::Vector{Exec}, flags::Pair{Symbol}...; kwargs...) where {P<:Package}\n\nCreate a input from the name and flags, other fields will set to default values.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.DFJob","page":"API reference","title":"DFControl.DFJob","text":"Represents a full DFT job with multiple input files and calculations.\n\n\n\n\n\n","category":"type"},{"location":"api/#DFControl.DFJob-Tuple{String}","page":"API reference","title":"DFControl.DFJob","text":"DFJob(job_dir::String; job_fuzzy = \"job\", kwargs...)\n\nLoads and returns a local DFJob. If job_dir is not a valid path the JOB_REGISTRY will be scanned for a job with matching directory. The kwargs will be passed to the DFJob constructor.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.Element","page":"API reference","title":"DFControl.Element","text":"Represents an element.\n\n\n\n\n\n","category":"type"},{"location":"api/#DFControl.Structure-Tuple{String}","page":"API reference","title":"DFControl.Structure","text":"Structure(cif_file::String; name = \"NoName\")\n\nCreates a structure from the supplied cif, and names it with the specified name.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.filesize-Tuple{DFJob}","page":"API reference","title":"Base.filesize","text":"Total filesize on disk for a job and all its versions.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{DFInput, Symbol}","page":"API reference","title":"Base.getindex","text":"Returns the flag with given symbol.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{DFJob, String}","page":"API reference","title":"Base.getindex","text":"Access an input inside the job using it's name. E.g job[\"scf\"]\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{DFJob, Symbol}","page":"API reference","title":"Base.getindex","text":"Searches through the inputs for the requested flag. If a flag was found the input and value of the flag will be added to the returned Dict.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setindex!-Tuple{DFInput, Any, Any}","page":"API reference","title":"Base.setindex!","text":"Sets the flag\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setindex!-Tuple{DFJob, Any, Symbol}","page":"API reference","title":"Base.setindex!","text":"Set one flag in all the appropriate inputs. E.g job[:ecutwfc] = 23.0\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.unique-Union{Tuple{Vector{A}}, Tuple{A}} where A<:DFControl.AbstractAtom","page":"API reference","title":"Base.unique","text":"Takes a Vector of atoms and returns a Vector with the atoms having unique symbols.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.abort-Tuple{DFJob}","page":"API reference","title":"DFControl.abort","text":"abort(job::DFJob)\n\nWill look for the job id inside it's metadata and try to remove it from the server queue. If the lastrunning input happened to be a QE input, the correct abort file will be written. If it's Wannier90 the job will be brutally removed from the slurm queue.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.addprojections!-Tuple{Any, Any, Any}","page":"API reference","title":"DFControl.addprojections!","text":"Adds projections to atoms.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.apply_fermi_level!-Tuple{DFControl.Band, Union{AbstractFloat, String}}","page":"API reference","title":"DFControl.apply_fermi_level!","text":"Mutatatively applies the fermi level to all eigvals in the band. If fermi is a quantum espresso scf output file it will try to find it in there.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.apply_fermi_level-Tuple{DFControl.Band, Any}","page":"API reference","title":"DFControl.apply_fermi_level","text":"Applies the fermi level to all eigvals in the band. If fermi is a quantum espresso scf output file it will try to find it in there.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.atom","page":"API reference","title":"DFControl.atom","text":"Returns the ith atom with id atsym.\n\n\n\n\n\n","category":"function"},{"location":"api/#DFControl.atoms-Tuple{DFControl.AbstractStructure, DFControl.Element}","page":"API reference","title":"DFControl.atoms","text":"All atoms that have element el.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.atoms-Tuple{DFControl.AbstractStructure, Symbol}","page":"API reference","title":"DFControl.atoms","text":"All atoms that have symbol s.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.atoms-Tuple{DFJob}","page":"API reference","title":"DFControl.atoms","text":"atoms(job::DFJob)\n\nReturns the atoms inside the structure of the job.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.atoms-Tuple{Function, DFControl.AbstractStructure}","page":"API reference","title":"DFControl.atoms","text":"Filter atoms depending on f.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.bandgap","page":"API reference","title":"DFControl.bandgap","text":"bandgap(bands::AbstractVector{DFBand}, fermi=0.0)\n\nCalculates the bandgap (possibly indirect) around the fermi level.\n\n\n\n\n\n","category":"function"},{"location":"api/#DFControl.bandgap-2","page":"API reference","title":"DFControl.bandgap","text":"bandgap(job::DFJob, fermi=nothing)\n\nCalculates the bandgap (possibly indirect) around the fermi level. Uses the first found bands calculation, if there is none it uses the first found nscf calculation.\n\n\n\n\n\n","category":"function"},{"location":"api/#DFControl.cardoption-Tuple{Any}","page":"API reference","title":"DFControl.cardoption","text":"Quantum espresso card option parser\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.cell_parameters-Tuple{SMatrix{3, 3, T, L} where {T, L}}","page":"API reference","title":"DFControl.cell_parameters","text":"cell_parameters(cell::Mat3)\ncell_parameters(str::Structure)\n\nParameters (a, b, c, α, β, γ) of the input cell returned in a named tuple.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.cif2structure-Tuple{String}","page":"API reference","title":"DFControl.cif2structure","text":"Uses cif2cell to Meta.parse a cif file, then returns the parsed structure.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.cleanup-Tuple{DFJob}","page":"API reference","title":"DFControl.cleanup","text":"Cleanup job files interactively.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.configuredefault_pseudos-Tuple{}","page":"API reference","title":"DFControl.configuredefault_pseudos","text":"configuredefault_pseudos(server = getdefault_server(), pseudo_dirs=getdefault_pseudodirs())\n\nReads the specified default_pseudo_dirs on the default_server and sets up the default_pseudos variable, and also adds all the entries to the user_defaults.jl file.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.convert_flags!-Tuple{DFInput}","page":"API reference","title":"DFControl.convert_flags!","text":"Runs through all the set flags and checks if they are allowed and set to the correct value\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.create_supercell-Tuple{DFControl.AbstractStructure, UnitRange, UnitRange, UnitRange}","page":"API reference","title":"DFControl.create_supercell","text":"create_supercell(structure::AbstractStructure, na::Int, nb::Int, nc::Int; make_afm=false)\ncreate_supercell(structure::AbstractStructure, na::UnitRange, nb::UnitRange, nc::UnitRange; make_afm=false)\n\nTakes a structure and creates a supercell from it with: the given amount of additional cells if (na::Int, nb::Int, nc::Int) along the a, b, c direction, or amount of cells specified by the ranges i.e. -1:1, -1:1, -1:1 would create a 3x3x3 supercell. If make_afm is set to true all the labels and magnetizations of the magnetic atoms will be reversed in a checkerboard fashion.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.data-Tuple{DFJob, String, Symbol}","page":"API reference","title":"DFControl.data","text":"data(job::DFJob, name::String, dataname::Symbol)\n\nLooks through the calculation filenames and returns the data with the specified symbol.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.distance-Tuple{DFControl.AbstractAtom, DFControl.AbstractAtom}","page":"API reference","title":"DFControl.distance","text":"distance(at1::AbstractAtom, at2::AbstractAtom)\n\nCalculates the distance between the two atoms.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.documentation-Tuple{Type{Elk}, AbstractString}","page":"API reference","title":"DFControl.documentation","text":"documentation(::Type{Elk}, searchstring::AbstractString)\n\nSearches through the description of all the known flags that can be set in Elk, returns the flags where the description contains the searchstring.\n\ndocumentation(::Type{Elk}, flag::Symbol)\n\nReturns the documentation for a given flag.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.documentation-Tuple{Type{QE}, AbstractString}","page":"API reference","title":"DFControl.documentation","text":"documentation(::Type{QE}, searchstring::AbstractString)\n\nSearches through the description of all the known flags that can be set in QuantumEspresso, returns the flags where the description contains the searchstring.\n\ndocumentation(::Type{Elk}, flag::Symbol)\n\nReturns the documentation for a given flag.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.elk_read_input-Tuple{String}","page":"API reference","title":"DFControl.elk_read_input","text":"elk_read_input(filename; execs=[Exec(\"elk\")], run=true, structure_name=\"noname\")\n\nReads an Elk input file. The ELK_EXEC inside execs gets used to find which flags are allowed in this input file, and convert the read values to the correct Types. Returns a DFInput{Elk} and the Structure that is found in the input.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.execs-Tuple{DFJob, Any}","page":"API reference","title":"DFControl.execs","text":"Returns the executables attached to a given input.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.gencalc_bands-Tuple{DFInput{QE}, Vector{var\"#s471\"} where var\"#s471\"<:(NTuple{4, T} where T), Vararg{Any, N} where N}","page":"API reference","title":"DFControl.gencalc_bands","text":"gencalc_bands(template::DFInput{QE}, kpoints::Vector{NTuple{4}}, newflags...; name=\"bands\")\ngencalc_bands(job::DFJob, kpoints::Vector{NTuple{4}}, newflags...; name=\"bands\", template_name=\"scf\")\n\nUses the information from the template and supplied kpoints to generate a bands input. Extra flags can be supplied which will be set for the generated input.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.gencalc_nscf-Tuple{DFInput{QE}, Tuple{Int64, Int64, Int64}, Vararg{Any, N} where N}","page":"API reference","title":"DFControl.gencalc_nscf","text":"gencalc_nscf(template::DFInput{QE}, kpoints::NTuple{3, Int}, newflags...; name=\"nscf\")\ngencalc_nscf(job::DFJob, kpoints::NTuple{3, Int}, newflags...; name=\"nscf\", template_name=\"scf\")\n\nUses the information from the template and supplied kpoints to generate an nscf input. Extra flags can be supplied which will be set for the generated input.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.gencalc_projwfc-Tuple{DFInput{QE}, Any, Any, Any, Vararg{Any, N} where N}","page":"API reference","title":"DFControl.gencalc_projwfc","text":"gencalc_projwfc(template::DFInput{QE}, Emin, Emax, DeltaE, newflags...; name=\"projwfc\")\ngencalc_projwfc(job::DFJob, Emin, Emax, DeltaE, newflags...; name=\"projwfc\", template_name=\"nscf\")\n\nUses the information from the template and supplied kpoints to generate a projwfc.x input. Extra flags can be supplied which will be set for the generated input.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.gencalc_scf-Tuple{DFInput{QE}, NTuple{6, Int64}, Vararg{Any, N} where N}","page":"API reference","title":"DFControl.gencalc_scf","text":"gencalc_scf(template::DFInput{QE}, kpoints::NTuple{6, Int}, newflags...; name=\"scf\")\n\nUses the information from the template and supplied kpoints to generate an scf input. Extra flags can be supplied which will be set for the generated input.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.gencalc_vcrelax","page":"API reference","title":"DFControl.gencalc_vcrelax","text":"gencalc_vcrelax(template::DFInput{QE}, kpoints::NTuple{6, Int}=data(template, :k_points).data, newflags...; name=\"scf\")\n\nUses the information from the template and supplied kpoints to generate a vcrelax input. Extra flags can be supplied which will be set for the generated input.\n\n\n\n\n\n","category":"function"},{"location":"api/#DFControl.gencalc_wan-Tuple{DFInput{QE}, DFControl.AbstractStructure, Any, Vararg{Any, N} where N}","page":"API reference","title":"DFControl.gencalc_wan","text":"gencalc_wan(nscf::DFInput{QE}, structure::AbstractStructure, Emin, wanflags...;\n            Epad     = 5.0,\n            wanexec  = Exec(\"wannier90.x\", \"\"))\n\nGenerates a Wannier90 input to follow on the supplied nscf calculation. It uses the projections defined in the structure, and starts counting the required amount of bands from Emin. The nscf needs to have a valid output since it will be used in conjunction with Emin to find the required amount of bands and energy window for the Wannier90 calculation.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.gencalc_wan-Tuple{DFInput{QE}, DFControl.AbstractStructure, DFInput{QE}, Real, Vararg{Any, N} where N}","page":"API reference","title":"DFControl.gencalc_wan","text":"gencalc_wan(nscf::DFInput{QE}, structure::AbstractStructure, projwfc::DFInput{QE}, threshold::Real, wanflags...; kwargs...)\n\nGenerates a wannier calculation, that follows on the nscf calculation. Instead of passing Emin manually, the output of a projwfc.x run can be used together with a threshold to determine the minimum energy such that the contribution of the projections to the DOS is above the threshold.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.gencalc_wan-Tuple{DFJob, Real, Vararg{Any, N} where N}","page":"API reference","title":"DFControl.gencalc_wan","text":"gencalc_wan(job::DFJob, min_window_determinator::Real, extra_wan_flags...; kwargs...)\n\nAutomates the generation of wannier calculations based on the job. When a projwfc calculation is present in the job, min_window_determinator will be used to determine the threshold value for including a band in the window based on the projections, otherwise it will be used as the Emin value from which to start counting the number of bands needed for all projections. extra_wan_flags can be any extra flags for the Wannier90 input such as write_hr etc.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.getdefault_pseudo","page":"API reference","title":"DFControl.getdefault_pseudo","text":"getdefault_pseudo(atom::Symbol, set=:default; specifier=nothing)\n\nReturns the pseudo potential string linked to the atom.\n\n\n\n\n\n","category":"function"},{"location":"api/#DFControl.getdefault_pseudodirs-Tuple{}","page":"API reference","title":"DFControl.getdefault_pseudodirs","text":"getdefault_pseudodirs()\n\nReturns the default pseudo dirs if it's defined. If it is not defined return nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.getdefault_server-Tuple{}","page":"API reference","title":"DFControl.getdefault_server","text":"getdefault_server()\n\nReturns the default server if it's defined. If it is not defined return \"\".\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.getfirst-Tuple{Function, Any}","page":"API reference","title":"DFControl.getfirst","text":"It's like filter()[1].\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.high_symmetry_kpath-Tuple{DFControl.AbstractStructure, Int64}","page":"API reference","title":"DFControl.high_symmetry_kpath","text":"high_symmetry_kpath(s::AbstractStructure, npoints_per_segment::Int; package=QE, kwargs...)\nhigh_symmetry_kpath(j::DFJob, npoints_per_segment::Int; package=QE, kwargs...)\n\nGenerates a QE bands calculation compliant high symmetry kpath, to be used with e.g. set_kpoints!(bands_input, kpoints). \n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.inputs","page":"API reference","title":"DFControl.inputs","text":"inputs(job::DFJob, names::Vector)\n\nReturns an array of the inputs that match the names.\n\n\n\n\n\n","category":"function"},{"location":"api/#DFControl.international-Tuple{DFJob}","page":"API reference","title":"DFControl.international","text":"international(j::DFJob; tolerance=1.0e-5)\ninternational(s::Structure; tolerance=1.0e-5)\n\nReturns the international symbol of the space group of the structure.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.isconverged-Tuple{DFInput{QE}}","page":"API reference","title":"DFControl.isconverged","text":"isconverged(input::DFInput{QE})\n\nReturns whether an scf calculation was converged.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.kgrid-Tuple{Any, Any, Any, Type{QE}}","page":"API reference","title":"DFControl.kgrid","text":"kgrid(na, nb, nc, input)\n\nReturns an array of k-grid points that are equally spaced, input can be either :wan or :nscf, the returned grids are appropriate as inputs for wannier90 or an nscf calculation respectively.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.mergestructures-Tuple{Vector{var\"#s109\"} where var\"#s109\"<:DFControl.AbstractStructure}","page":"API reference","title":"DFControl.mergestructures","text":"Takes a vector of structures and merges all the attributes of the atoms.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.mkserverdir-Tuple{Any, Any}","page":"API reference","title":"DFControl.mkserverdir","text":"Tests whether a directory exists on a server and if not, creates it.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.niggli_reduce-Tuple{DFJob}","page":"API reference","title":"DFControl.niggli_reduce","text":"niggli_reduce(j::DFJob; tolerance=1.0e-5)\nniggli_reduce(s::Structure; tolerance=1.0e-5)\n\nReturns the niggli reduced lattice cell.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.outpath-Tuple{DFJob, String}","page":"API reference","title":"DFControl.outpath","text":"Finds the input corresponding to the name and returns the full output path.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.outputdata-Tuple{DFInput}","page":"API reference","title":"DFControl.outputdata","text":"Returns the outputdata for the input.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.outputdata-Tuple{DFJob, Vector{DFInput}}","page":"API reference","title":"DFControl.outputdata","text":"Finds the output files for each of the inputs of a job, and groups all found data into a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.parse_block-Tuple{Any, Vararg{Any, N} where N}","page":"API reference","title":"DFControl.parse_block","text":"parse_block(f, types...; to_strip=',')\n\nTakes the specified types and parses each line into the types. When it finds a line where it cannot match all the types, it stops and returns  the parsed values. The split and strip keywords let the user specify how to first split the line, then strip the splits from the strip char.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.parse_line-Tuple{Type, String}","page":"API reference","title":"DFControl.parse_line","text":"Parse a line for occurrences of type T.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.parse_string_array-Tuple{Type, Any}","page":"API reference","title":"DFControl.parse_string_array","text":"Parse an array of strings into an array of a type.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.pdos","page":"API reference","title":"DFControl.pdos","text":"Reads the pdos for a particular atom. Only works for QE.\n\n\n\n\n\n","category":"function"},{"location":"api/#DFControl.polyhedron-Tuple{DFControl.AbstractAtom, Vector{var\"#s115\"} where var\"#s115\"<:DFControl.AbstractAtom, Int64}","page":"API reference","title":"DFControl.polyhedron","text":"polyhedron(at::AbstractAtom, atoms::Vector{<:AbstractAtom}, order::Int)\npolyhedron(at::AbstractAtom, str::AbstractStructure, order::Int)\n\nReturns a polyhedron around the atom, i.e. the order closest atoms. The returned atoms will be ordered according to their distance to the first one. In the case of a structure rather than a set of atoms, the search will be performed over all atoms in the structure.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.positions-Tuple{Vector{var\"#s72\"} where var\"#s72\"<:DFControl.AbstractAtom, Symbol}","page":"API reference","title":"DFControl.positions","text":"Extracts all the positions of the atoms and puts them in a vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.projections","page":"API reference","title":"DFControl.projections","text":"Returns the projections inside the job for the specified ith atom in the job with id atsym.\n\n\n\n\n\n","category":"function"},{"location":"api/#DFControl.projections-Tuple{DFJob}","page":"API reference","title":"DFControl.projections","text":"Returns all the projections inside the job.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.pullfile-NTuple{4, String}","page":"API reference","title":"DFControl.pullfile","text":"pullfile(server::String, server_dir::String, local_dir::String, filename::String)\n\nPulls a file from the specified server and server dir to the local dir.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.pullfile-Tuple{String, String, String}","page":"API reference","title":"DFControl.pullfile","text":"pullfile(server_dir::String, local_dir::String, filename::String; server=getdefault_server())\n\nPulls a file from the default server if the default server is specified.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.pullfile-Tuple{String, String}","page":"API reference","title":"DFControl.pullfile","text":"pullfile(filepath::String, local_dir::String; server=getdefault_server(), local_filename=nothing)\n\nPulls a file from the default server if the default server is specified.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.pulljob-Tuple{String, String, String}","page":"API reference","title":"DFControl.pulljob","text":"pulljob(server::String, server_dir::String, local_dir::String; job_fuzzy=\"*job*\")\n\nPulls job from server. If no specific inputs are supplied it pulls all .in and .tt files.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.pulloutputs","page":"API reference","title":"DFControl.pulloutputs","text":"pulloutputs(job::DFJob, server=\"\", server_dir=\"\", local_dir=\"\"; job_fuzzy=\"*job*\", extras=String[])\n\nFirst pulls the job file (specified by job_fuzzy), reads the possible output files and tries to pull them. Extra files to pull can be specified by the extras keyword, works with fuzzy filenames.\n\n\n\n\n\n","category":"function"},{"location":"api/#DFControl.push-Tuple{DFJob}","page":"API reference","title":"DFControl.push","text":"push(job::DFJob)\n\nPushes a DFJob from it's local directory to its server side directory.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.qdel-Tuple{String, Int64}","page":"API reference","title":"DFControl.qdel","text":"Deletes the job from the local or server queue.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.qe_read_input-Tuple{Any}","page":"API reference","title":"DFControl.qe_read_input","text":"qe_read_input(filename, T=Float64; execs=[Exec(\"pw.x\")], run=true, structure_name=\"noname\")\n\nReads a Quantum Espresso input file. The QE_EXEC inside execs gets used to find which flags are allowed in this input file, and convert the read values to the correct Types. Returns a DFInput{QE} and the Structure that is found in the input.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.qe_read_kpdos","page":"API reference","title":"DFControl.qe_read_kpdos","text":"qe_read_kpdos(filename::String,column=1;fermi=0)\n\nReads the kresolved partial density of states from a Quantum Espresso projwfc output file. Only use this if the flag kresolveddos=true in the projwfc input file!! The returned matrix can be readily plotted using heatmap() from Plots.jl! Optional input: column = 1 (column of the output, 1 = first column after ik and E) fermi  = 0 (possible fermi offset of the read energy values) Return:         Array{Float64,2}(length(kpoints),length(energies)) , (ytickvals,yticks)\n\n\n\n\n\n","category":"function"},{"location":"api/#DFControl.qe_read_pdos-Tuple{String}","page":"API reference","title":"DFControl.qe_read_pdos","text":"qe_read_pdos(filename::String)\n\nReads partial dos file.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.qe_read_projwfc-Tuple{String}","page":"API reference","title":"DFControl.qe_read_projwfc","text":"qe_read_projwfc(filename::String)\n\nReads the output file of a projwfc.x calculation. Each kpoint will have as many energy dos values as there are bands in the scf/nscf calculation that generated the density upon which the projwfc.x was called. Returns:     states: [(:atomid, :wfcid, :j, :l, :m),...] where each j==0 for a non spin polarized calculation.     kpdos : kpoint => [(:e, :ψ, :ψ²), ...] where ψ is the coefficient vector in terms of the states.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.qe_read_pw_output","page":"API reference","title":"DFControl.qe_read_pw_output","text":"qe_read_pw_output(filename::String, T=Float64)\n\nReads a pw quantum espresso input, returns a dictionary with all found data in the file.\n\n\n\n\n\n","category":"function"},{"location":"api/#DFControl.qstat-Tuple{Any}","page":"API reference","title":"DFControl.qstat","text":"qstat(server)\n\nIf sbatch is running on server it will return the output of the qstat command.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.readbands-Tuple{DFInput}","page":"API reference","title":"DFControl.readbands","text":"readbands(input::DFInput)\n\nTries to read bands from the outputfile of the input.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.readbands-Tuple{DFJob}","page":"API reference","title":"DFControl.readbands","text":"Searches for the first bands calculation with output, and reads the fermi level from it.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.readfermi-Tuple{DFInput}","page":"API reference","title":"DFControl.readfermi","text":"readfermi(input::DFInput)\n\nTries to read the fermi level from the outputfile of the input.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.readfermi-Tuple{DFJob}","page":"API reference","title":"DFControl.readfermi","text":"Searches for the first scf or nscf calculation with output, and reads the fermi level from it.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.removedefault_pseudodir-Tuple{Symbol}","page":"API reference","title":"DFControl.removedefault_pseudodir","text":"removedefault_pseudodir(pseudo_symbol::Symbol)\n\nRemoves entry with flag pseudo_symbol from the default_pseudodirs and user_defaults.jl file.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.removedefault_pseudos-Tuple{Symbol}","page":"API reference","title":"DFControl.removedefault_pseudos","text":"removedefault_pseudos(pseudo_symbol::Symbol)\n\nRemoves all pseudo entries with flag pseudo_symbol from the default_pseudos.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.rm_flags!-Tuple{DFInput, Vararg{Any, N} where N}","page":"API reference","title":"DFControl.rm_flags!","text":"rm_flags!(input::DFInput, flags...)\n\nRemove the specified flags.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.rm_flags!-Tuple{DFJob, Vector{var\"#s471\"} where var\"#s471\"<:DFInput, Vararg{Any, N} where N}","page":"API reference","title":"DFControl.rm_flags!","text":"rm_flags!(job::DFJob, inputs::Vector{<:DFInput}, flags...)\n\nLooks through the input names and removes the specified flags.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.rm_tmp_dirs!","page":"API reference","title":"DFControl.rm_tmp_dirs!","text":"Removes temporary directories of the specified job versions.\n\n\n\n\n\n","category":"function"},{"location":"api/#DFControl.rm_version!-Tuple{DFJob, Any}","page":"API reference","title":"DFControl.rm_version!","text":"Removes the job version if it exists.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.rm_versions!-Tuple{Any, Vararg{Any, N} where N}","page":"API reference","title":"DFControl.rm_versions!","text":"Removes the job versions if they exist.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.rmexecflags!-Tuple{DFJob, Any, Vararg{Any, N} where N}","page":"API reference","title":"DFControl.rmexecflags!","text":"rmexecflags!(job::DFJob, exec, flags...)\n\nGoes through the calculations of the job and removes the specified exec flags.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.runninginput-Tuple{DFJob}","page":"API reference","title":"DFControl.runninginput","text":"Checks the last created output file for a certain job.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.sanitize_flags!-Tuple{DFInput, DFControl.AbstractStructure}","page":"API reference","title":"DFControl.sanitize_flags!","text":"sanitize_flags!(input::DFInput, str::AbstractStructure)\n\nCleans up flags, i.e. remove flags that are not allowed and convert all flags to the correct types. Tries to correct common errors for different input types.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.sanitize_flags!-Tuple{DFJob}","page":"API reference","title":"DFControl.sanitize_flags!","text":"Runs some checks on the set flags for the inputs in the job, and sets metadata (:prefix, :outdir etc) related flags to the correct ones. It also checks whether flags in the various inputs are allowed and set to the correct types.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.scale_bondlength!-Tuple{DFControl.AbstractAtom, DFControl.AbstractAtom, Real, SMatrix{3, 3, T, L} where {T, L}}","page":"API reference","title":"DFControl.scale_bondlength!","text":"scale_bondlength!(at1::AbstractAtom, at2::AbstractAtom, scale::Real, cell::Mat3)\n\nScales the bondlength between two atoms. The center of mass remains the same.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.scale_cell!-Tuple{DFJob, Any}","page":"API reference","title":"DFControl.scale_cell!","text":"Rescales the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.scale_cell!-Tuple{Structure, Matrix{T} where T}","page":"API reference","title":"DFControl.scale_cell!","text":"Rescales the cell of the structure.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.searchdir-Tuple{String, Any}","page":"API reference","title":"DFControl.searchdir","text":"Searches a directory for all files containing the key.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.searchinput-Tuple{DFJob, AbstractString}","page":"API reference","title":"DFControl.searchinput","text":"Fuzzily search the first input in the job whose name contains the fuzzy.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.searchinputs-Tuple{DFJob, AbstractString}","page":"API reference","title":"DFControl.searchinputs","text":"Fuzzily search inputs in the job whose name contain the fuzzy.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.searchinputs-Union{Tuple{P}, Tuple{DFJob, Type{P}}} where P<:DFControl.Package","page":"API reference","title":"DFControl.searchinputs","text":"Returns all inputs from a certain package.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_Hubbard_J!-Tuple{DFJob, Vararg{Pair{Symbol, var\"#s111\"} where var\"#s111\"<:(Vector{var\"#s110\"} where var\"#s110\"<:AbstractFloat), N} where N}","page":"API reference","title":"DFControl.set_Hubbard_J!","text":"set_Hubbard_J!(job::DFJob, ats_Js::Pair{Symbol, Vector{<:AbstractFloat}}...; print=true)\n\nSet the Hubbard J parameter for the specified atom.\n\nExample: \t`setHubbardJ(job, :Ir => [2.1], :Ni => [1.0])'\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_Hubbard_J!-Union{Tuple{T}, Tuple{DFControl.AbstractAtom{T, LT} where LT<:(Union{Quantity{T, 𝐋, U}, Level{L, S, Quantity{T, 𝐋, U}} where {L, S}} where U), Vector{var\"#s110\"} where var\"#s110\"<:AbstractFloat}} where T","page":"API reference","title":"DFControl.set_Hubbard_J!","text":"set_Hubbard_J!(at::AbstractAtom, v::Vector{<:AbstractFloat}; print=true)\n\nSet the Hubbard J parameter for the specified atom.\n\nExample: \t`setHubbardJ(at, [2.1])'\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_Hubbard_J0!-Tuple{DFJob, Vararg{Pair{Symbol, var\"#s116\"} where var\"#s116\"<:AbstractFloat, N} where N}","page":"API reference","title":"DFControl.set_Hubbard_J0!","text":"set_Hubbard_J0!(job::DFJob, ats_J0s::Pair{Symbol, <:AbstractFloat}...; print=true)\n\nSet the Hubbard J0 parameter for the specified atoms.\n\nExample: \tset_Hubbard_J0!(job, :Ir => 2.1, :Ni => 1.0, :O => 0.0)\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_Hubbard_J0!-Union{Tuple{T}, Tuple{DFControl.AbstractAtom{T, LT} where LT<:(Union{Quantity{T, 𝐋, U}, Level{L, S, Quantity{T, 𝐋, U}} where {L, S}} where U), AbstractFloat}} where T","page":"API reference","title":"DFControl.set_Hubbard_J0!","text":"set_Hubbard_J0!(at::AbstractAtom, v::AbstractFloat; print=true)\n\nSet the Hubbard J0 parameter for the specified atom.\n\nExample: \t`setHubbardJ0!(at, 2.1)'\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_Hubbard_U!-Tuple{DFJob, Vararg{Pair{Symbol, var\"#s116\"} where var\"#s116\"<:AbstractFloat, N} where N}","page":"API reference","title":"DFControl.set_Hubbard_U!","text":"set_Hubbard_U!(job::DFJob, ats_Us::Pair{Symbol, <:AbstractFloat}...; print=true)\n\nSet the Hubbard U parameter for the specified atoms.\n\nExample: \tset_Hubbard_U!(job, :Ir => 2.1, :Ni => 1.0, :O => 0.0)\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_Hubbard_U!-Union{Tuple{T}, Tuple{DFControl.AbstractAtom{T, LT} where LT<:(Union{Quantity{T, 𝐋, U}, Level{L, S, Quantity{T, 𝐋, U}} where {L, S}} where U), AbstractFloat}} where T","page":"API reference","title":"DFControl.set_Hubbard_U!","text":"set_Hubbard_U!(at::AbstractAtom, v::AbstractFloat; print=true)\n\nSet the Hubbard U parameter for the specified atom.\n\nExample: \t`setHubbardU!(at, 2.1)'\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_Hubbard_α!-Tuple{DFJob, Vararg{Pair{Symbol, var\"#s116\"} where var\"#s116\"<:AbstractFloat, N} where N}","page":"API reference","title":"DFControl.set_Hubbard_α!","text":"set_Hubbard_α!(job::DFJob, ats_αs::Pair{Symbol, <:AbstractFloat}...; print=true)\n\nSet the Hubbard α parameter for the specified atoms.\n\nExample: \tset_Hubbard_α!(job, :Ir => 2.1, :Ni => 1.0, :O => 0.0)\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_Hubbard_α!-Union{Tuple{T}, Tuple{DFControl.AbstractAtom{T, LT} where LT<:(Union{Quantity{T, 𝐋, U}, Level{L, S, Quantity{T, 𝐋, U}} where {L, S}} where U), AbstractFloat}} where T","page":"API reference","title":"DFControl.set_Hubbard_α!","text":"set_Hubbard_α!(at::AbstractAtom, v::AbstractFloat; print=true)\n\nSet the Hubbard α parameter for the specified atom.\n\nExample: \t`setHubbardα!(at, 2.1)'\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_Hubbard_β!-Tuple{DFJob, Vararg{Pair{Symbol, var\"#s116\"} where var\"#s116\"<:AbstractFloat, N} where N}","page":"API reference","title":"DFControl.set_Hubbard_β!","text":"set_Hubbard_β!(job::DFJob, ats_βs::Pair{Symbol, <:AbstractFloat}...; print=true)\n\nSet the Hubbard β parameter for the specified atoms.\n\nExample: \tset_Hubbard_β!(job, :Ir => 2.1, :Ni => 1.0, :O => 0.0)\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_Hubbard_β!-Union{Tuple{T}, Tuple{DFControl.AbstractAtom{T, LT} where LT<:(Union{Quantity{T, 𝐋, U}, Level{L, S, Quantity{T, 𝐋, U}} where {L, S}} where U), AbstractFloat}} where T","page":"API reference","title":"DFControl.set_Hubbard_β!","text":"set_Hubbard_β!(at::AbstractAtom, v::AbstractFloat; print=true)\n\nSet the Hubbard β parameter for the specified atom.\n\nExample: \t`setHubbardβ!(at, 2.1)'\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_atoms!-Tuple{DFJob, Vector{var\"#s474\"} where var\"#s474\"<:DFControl.AbstractAtom}","page":"API reference","title":"DFControl.set_atoms!","text":"job.structure.atoms = atoms\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_cell!-Tuple{DFJob, SMatrix{3, 3, T, L} where {T, L}}","page":"API reference","title":"DFControl.set_cell!","text":"set_cell!(job::DFJob, cell_::Mat3)\n\nsets the cell parameters of the structure in the job.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_cutoffs!-Tuple{DFJob}","page":"API reference","title":"DFControl.set_cutoffs!","text":"Reads throught the pseudo files and tries to figure out the correct cutoffs\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_data!-Tuple{DFInput, InputData}","page":"API reference","title":"DFControl.set_data!","text":"set_data!(input::DFInput, data::InputData)\n\nAdds the given data to the input. Should put it in the correct arrays.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_data!-Tuple{DFInput, Symbol, Any}","page":"API reference","title":"DFControl.set_data!","text":"set_data!(input::DFInput, block_name::Symbol, new_block_data; option=nothing, print=true)\n\nsets the data of the specified 'InputData' to the new data. Optionally also sets the 'InputData' option.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_data!-Tuple{DFJob, Vector{var\"#s471\"} where var\"#s471\"<:DFInput, Symbol, Any}","page":"API reference","title":"DFControl.set_data!","text":"set_data!(job::DFJob, inputs::Vector{<:DFInput}, dataname::Symbol, data; option=nothing)\n\nLooks through the calculation filenames and sets the data of the datablock with data_block_name to new_block_data. if option is specified it will set the block option to it.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_dataoption!-Tuple{DFInput, Symbol, Symbol}","page":"API reference","title":"DFControl.set_dataoption!","text":"set_dataoption!(input::DFInput, name::Symbol, option::Symbol; print=true)\n\nSets the option of specified data.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_dataoption!-Tuple{DFJob, Symbol, Symbol}","page":"API reference","title":"DFControl.set_dataoption!","text":"set_dataoption!(job::DFJob, name::Symbol, option::Symbol)\n\nsets the option of specified data block in all calculations that have the block.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_dataoption!-Tuple{DFJob, Vector{String}, Symbol, Symbol}","page":"API reference","title":"DFControl.set_dataoption!","text":"set_dataoption!(job::DFJob, names::Vector{String}, dataname::Symbol, option::Symbol)\n\nsets the option of specified data in the specified inputs.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_execdir!-Tuple{DFJob, Any, Any}","page":"API reference","title":"DFControl.set_execdir!","text":"Sets the directory of the specified executable.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_execflags!-Tuple{DFJob, Any, Vararg{Any, N} where N}","page":"API reference","title":"DFControl.set_execflags!","text":"set_execflags!(job::DFJob, exec, flags...)\n\nGoes through the calculations of the job and sets the exec flags to the specified ones.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_flags!-Tuple{DFJob, Vector{var\"#s114\"} where var\"#s114\"<:DFInput, Vararg{Any, N} where N}","page":"API reference","title":"DFControl.set_flags!","text":"set_flags!(job::DFJob, inputs::Vector{<:DFInput}, flags...; print=true)\n\nSets the flags in the names to the flags specified. This only happens if the specified flags are valid for the names. If necessary the correct control block will be added to the calculation (e.g. for QEInputs).\n\nThe values that are supplied will be checked whether they are valid.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_flags!-Union{Tuple{T}, Tuple{DFInput{T}, Vararg{Any, N} where N}} where T","page":"API reference","title":"DFControl.set_flags!","text":"set_flags!(input::DFInput, flags...; print=true)\n\nSets the specified flags in the input.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_flow!-Tuple{DFJob, Vararg{Any, N} where N}","page":"API reference","title":"DFControl.set_flow!","text":"set_flow!(job::DFJob, should_runs...)\n\nSets whether or not calculations should be run. Calculations are specified using their indices.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_headerword!-Tuple{DFJob, Pair{String, String}}","page":"API reference","title":"DFControl.set_headerword!","text":"set_headerword!(job::DFJob, old_new::Pair{String, String})\n\nReplaces the specified word in the header with the new word.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_kpoints!-Tuple{DFInput{Wannier90}, Tuple{Int64, Int64, Int64}}","page":"API reference","title":"DFControl.set_kpoints!","text":"set_kpoints!(input::DFInput, k_grid::NTuple{3, Int})\n\nSets the kpoints of the input.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_kpoints!-Tuple{DFJob, String, Any}","page":"API reference","title":"DFControl.set_kpoints!","text":"set_kpoints!(job::DFJob, name::String, k_points)\n\nsets the data in the k point DataBlock inside the specified inputs.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_localdir!-Tuple{DFJob, String}","page":"API reference","title":"DFControl.set_localdir!","text":"set_localdir!(job::DFJob, dir::String; copy=false)\n\nSets the directory where the job will be saved or ran. If necessary the directory will be created. If copy is set to true, all previous inputs and output files of the current job version (i.e. those in the main job directory) will be copied to the new directory, including the outputs directory with temporary files created during jobs runs.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_name!-Tuple{DFInput, AbstractString}","page":"API reference","title":"DFControl.set_name!","text":"set_name!(input::DFInput, name::AbstractString)\n\nSets the name of input to name and updates input.infile and input.outfile to conform with the new name.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_position!-Union{Tuple{T}, Tuple{DFControl.AbstractAtom, AbstractVector{T}, SMatrix{3, 3, T, L} where {T, L}}} where T<:Real","page":"API reference","title":"DFControl.set_position!","text":"set_position!(at::AbstractAtom, pos::AbstractVector{T}, unit_cell::Mat3) where {T<:Real}\n\nUpdates the position of the atom to this. The unit cell is used to make sure both position_cryst and position_cart are correct.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_projections!-Tuple{DFJob, Vararg{Any, N} where N}","page":"API reference","title":"DFControl.set_projections!","text":"sets the projections of the specified atoms inside the job structure.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_projections!-Tuple{Structure, Vararg{Pair, N} where N}","page":"API reference","title":"DFControl.set_projections!","text":"set_projections!(str::Structure, projs::Pair...; soc=false)\n\nSets the projections of the specified atoms. projs has to be of form :atsym => [:proj], where proj = :s, :p, :d, :f, etc. If soc is set to true both up and down projections will be taken into account.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_pseudos!","page":"API reference","title":"DFControl.set_pseudos!","text":"sets the pseudopotentials to the specified one in the default pseudoset.\n\n\n\n\n\n","category":"function"},{"location":"api/#DFControl.set_pseudos!-2","page":"API reference","title":"DFControl.set_pseudos!","text":"sets the pseudopotentials for the atom with name atsym to the specified one in the default pseudoset.\n\n\n\n\n\n","category":"function"},{"location":"api/#DFControl.set_pseudos!-Tuple{DFJob, Vararg{Pair{Symbol, Pseudo}, N} where N}","page":"API reference","title":"DFControl.set_pseudos!","text":"sets the pseudopotentials to the specified one in the default pseudoset.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_serverdir!-Tuple{Any, Any}","page":"API reference","title":"DFControl.set_serverdir!","text":"Sets the server dir of the job.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_wanenergies!-Tuple{DFInput{Wannier90}, DFControl.AbstractStructure, DFInput, Real}","page":"API reference","title":"DFControl.set_wanenergies!","text":"set_wanenergies!(waninput::DFInput{Wannier90}, structure::AbstractStructure, nscf::DFInput , Emin::Real; Epad=5.0)\n\nAutomatically calculates and sets the wannier energies. This uses the projections, Emin and the output of the nscf calculation to infer the other limits. Epad allows one to specify the padding around the inner and outer energy windows\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_wanenergies!-Tuple{DFJob, DFInput, DFInput, Real}","page":"API reference","title":"DFControl.set_wanenergies!","text":"set_wanenergies!(job::DFJob, nscf::DFInput{QE}, projwfc::DFInput{QE}, threshold::Real; Epad=5.0)\n\nWill set the energy window limits correctly according to the projections specified in the structure of the job. The output of projwfc and the threshold will be used to determine the minimum limit of the frozen energy window such that the interesting DOS of inside it exceeds the threshold. nscf will be used to determine the DOS, and what the upper limit of the frozen window needs to be to fit enough bands inside it, depending on the projections.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_wanenergies!-Tuple{DFJob, DFInput, Real}","page":"API reference","title":"DFControl.set_wanenergies!","text":"set_wanenergies!(job::DFJob, nscf::DFInput{QE}, Emin::Real; Epad=5.0)\n\nWill set the energy window limits correctly according to the projections specified in the structure of the job and the specified Emin. The output of nscf will be used to determine the DOS, and what the size of the frozen window needs to be to fit enough bands inside it, depending on the projections.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.set_wanenergies!-Tuple{DFJob, Real}","page":"API reference","title":"DFControl.set_wanenergies!","text":"set_wanenergies!(job::DFJob, min_window_determinator::Real; kwargs...)\n\nSets the energy windows of wannier calculations based on the job. When a projwfc calculation is present in the job, min_window_determinator will be used to determine the threshold value for including a band in the window based on the projections, otherwise it will be used as the Emin value from which to start counting the number of bands needed for all projections.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.setdefault_jobheader-Tuple{Any}","page":"API reference","title":"DFControl.setdefault_jobheader","text":"setdefault_jobheader(lines)\n\nSets the header that will get added to each job.tt file, if no other header was specified.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.setdefault_pseudodir-Tuple{Symbol, String}","page":"API reference","title":"DFControl.setdefault_pseudodir","text":"setdefault_pseudodir(pseudo_symbol::Symbol, dir::String)\n\nAdds an entry inside the default_pseudodirs with flag pseudo_symbol, and adds it to the user_defaults.jl file.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.setdefault_server-Tuple{String}","page":"API reference","title":"DFControl.setdefault_server","text":"setdefault_server(server::String)\n\nSets the default server variable, and also adds it to the user_defaults.jl file.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.slurm_history_jobdir","page":"API reference","title":"DFControl.slurm_history_jobdir","text":"slurm_history_jobdir(stardate=yesterday())\n\nReturns the unique job directories of the jobs that ran since the startdate. Startdate should be printed in following format: yyyy-mm-dd.\n\n\n\n\n\n","category":"function"},{"location":"api/#DFControl.slurm_isqueued-Tuple{DFJob}","page":"API reference","title":"DFControl.slurm_isqueued","text":"slurm_isqueued(job::DFJob)\n\nReturns whether the job is queued.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.slurm_isrunning-Tuple{DFJob}","page":"API reference","title":"DFControl.slurm_isrunning","text":"slurm_isrunning(job::DFJob)\n\nReturns whether the job is running.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.slurm_jobid","page":"API reference","title":"DFControl.slurm_jobid","text":"slurm_jobid(job::DFJob, startdate=yesterday())\n\nLooks through the jobs since the startdate and returns the job ID if found. Returns -1 if the jobID was not found in the list of jobs since startdate.\n\n\n\n\n\n","category":"function"},{"location":"api/#DFControl.slurm_mostrecent","page":"API reference","title":"DFControl.slurm_mostrecent","text":"slurm_mostrecent(index=1, jobfile=\"job.tt\", startdate=lastmonth(), args...; kwargs...)\n\nReturns whether the indexth most recent job with job script jobfile. Extra args and kwargs will be passed to the DFJob constructor.\n\n\n\n\n\n","category":"function"},{"location":"api/#DFControl.strip_split-Tuple{Any, Vararg{Any, N} where N}","page":"API reference","title":"DFControl.strip_split","text":"Splits a line using arguments, then strips spaces from the splits.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.submit-Tuple{DFJob}","page":"API reference","title":"DFControl.submit","text":"submit(job::DFJob; server=job.server, server_dir=job.server_dir, rm_prev=true, kwargs...)\n\nSaves the job locally, and then either runs it locally using qsub (when job.server == \"localhost\") or sends it to the specified job.server in job.server_dir, and submits it using qsub on the server. Kwargs get passed through to save(job; kwargs...). If rm_prev == true previous job.tt output files will be removed.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.symmetry_operators-Tuple{DFJob}","page":"API reference","title":"DFControl.symmetry_operators","text":"symmetry_operators(j::DFJob; maxsize=52, tolerance=1.0e-5)\nsymmetry_operators(s::Structure; maxsize=52, tolerance=1.0e-5)\n\nFinds and returns all the rotations and translations that are symmetry operators of the structure.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.update_geometry!-Tuple{DFControl.AbstractStructure, DFControl.AbstractStructure}","page":"API reference","title":"DFControl.update_geometry!","text":"update_geometry!(str1::AbstractStructure, str2::AbstractStructure)\nupdate_geometry!(job::DFJob, str2::AbstractStructure)\n\nUpdates the spatial parameters of the atoms and cell of the first structure to those found in the second.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.volume-Tuple{SMatrix{3, 3, T, L} where {T, L}}","page":"API reference","title":"DFControl.volume","text":"volume(cell::Mat3)\nvolume(str::Structure)\n\nCalculates the volume for the unit cell.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.wan_read_input","page":"API reference","title":"DFControl.wan_read_input","text":"wan_read_input(filename::String, T=Float64; runcommand= Exec(\"\"), run=true, exec=Exec(\"wannier90.x\"), structure_name=\"NoName\")\n\nReads a DFInput{Wannier90} and the included Structure from a WANNIER90 input file.\n\n\n\n\n\n","category":"function"},{"location":"api/#DFControl.wan_read_output-Tuple{Any}","page":"API reference","title":"DFControl.wan_read_output","text":"wan_read_output(filename)\n\nReads an outputfile for wannier. Parsed info:     :disentanglement,     :wannierise,     :final_state,\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.watch_qstat-Tuple{Any}","page":"API reference","title":"DFControl.watch_qstat","text":"watch_qstat(server)\n\nIf sbatch is running on server it will return the output of the watch qstat command.\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.writeabortfile-Tuple{DFJob, DFInput{QE}}","page":"API reference","title":"DFControl.writeabortfile","text":"LOL this absolutely is impossible to do for QE\n\n\n\n\n\n","category":"method"},{"location":"api/#DFControl.writejobfiles-Tuple{DFJob}","page":"API reference","title":"DFControl.writejobfiles","text":"writejobfiles(job::DFJob; kwargs...)\n\nWrites all the input files and job file that are linked to a DFJob. Kwargs will be passed down to various writetojob functions.\n\n\n\n\n\n","category":"method"},{"location":"api/#FileIO.save","page":"API reference","title":"FileIO.save","text":"save(input::DFInput{QE}, structure, filename::String=inpath(input))\n\nWrites a Quantum Espresso input file.\n\n\n\n\n\n","category":"function"},{"location":"api/#FileIO.save-2","page":"API reference","title":"FileIO.save","text":"save(input::DFInput{Wannier90}, structure, filename::String=inpath(input))\n\nWrites the DFInput{Wannier90} and structure to a file, that can be interpreted by WANNIER90. The atoms in the structure must have projections defined.\n\n\n\n\n\n","category":"function"},{"location":"api/#FileIO.save-3","page":"API reference","title":"FileIO.save","text":"save(job::DFJob)\n\nSaves a DFJob, it's job file and all it's input files.\n\n\n\n\n\n","category":"function"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"EditURL = \"https://github.com/louisponet/DFControl.jl/blob/master/docs/src/guide/advanced_tutorial.jl\"","category":"page"},{"location":"guide/advanced_tutorial/#Advanced-Usage","page":"Advanced Tutorial","title":"Advanced Usage","text":"","category":"section"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"In this tutorial we will continue from the job created in the Basic Tutorial, and demonstrate some more advanced functionality that DFControl offers.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"To load a previously saved job we here provide a valid job directory with a job.tt script in it.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"using DFControl\n\ntjob = DFJob(joinpath(pathof(DFControl), \"..\",\"..\",\"docs\", \"src\", \"assets\", \"job\"))#hide\ntjob2 = DFJob(joinpath(pathof(DFControl), \"..\",\"..\", \"docs\", \"src\", \"assets\", \"Job2\"))#hide\ntry#hide\nglobal job = DFJob(\"job\")\ncatch#hide\nglobal job = deepcopy(tjob)#hide\nset_localdir!(job, \"job\"); #hide\njob#hide\nend#hide","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Since the job created in the Basic Tutorial was saved in the \"job\" directory this will work, see the section on Jobs for further details and options on how to load previously saved jobs.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"The next thing we may want to do is to change the directory where the job is running.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"try#hide\nset_localdir!(job, \"Job2\", copy=true)\ncatch#hide\nglobal job = deepcopy(tjob2);#hide\npop!(job);#hide\npop!(job);#hide\njob#hide\nend#hide","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"With the copy=true flag we let DFControl know that not only to create and set the new directory, but also to copy the previous results and temporary files to the new directory so we don't have to rerun the scf calculation.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Next we would like to plot the projected density of states. For that we create both an nscf calculation to get a uniform k-grid, and projwfc input.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"push!(job, gencalc_nscf(job[\"scf\"], (6,6,6)))","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"The second argument of gencalc_nscf is the kgrid. When passing a 3-Tuple, the code will assume that an explicit k-grid is requested, which can be verified by","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"data(job[\"nscf\"], :k_points)","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Next we generate a projwfc input using the fermi level as a guide for the energy window. The arguments are structured as (template, Emin, Emax, deltaE) respectively.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"fermi = readfermi(job)\npush!(job, gencalc_projwfc(job[\"nscf\"], fermi-10, fermi+1, 0.1))","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Next we disable the bands calculation, run the new ones, and plot the results","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"job[\"bands\"].run = false\ntry#hide\nsubmit(job)\ncatch#hide\nglobal job = deepcopy(tjob2)#hide\nend#hide\nusing Plots\nplot(job, -10, 1)","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"As we can see, again DFControl identifies the additional information that is now present in the job, and uses it to display in the plot.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"In the demonstrated case we see that everything went according to plan, however, often things need to be changed in a trial and error way until the desired results are found.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"On common occurence is that input flags have to be set, or changed. This can be done in two ways","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"job[:ecutwfc] = 40.0","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"will go through all the inputs of the job and set the flag if it is allowed, i.e. the flag will not be set in the projwfc input since it makes no sense.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"job[\"bands\"][:nbnd] = 30","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"This will set a flag for one specific calculation, again checking whether the flag is valid, and the type will be converted to the correct one.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"In order to quickly specify what calculations to schedule and which not, one can use","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"set_flow!(job, \"\" => false, \"scf\" => true)","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"As we can see, only the scf and nscf calculations are scheduled to run now, this is because for each of the pairs in the arguments of set_flow!, every input inside the job for which the string occurs in the name will be set to run or not depending on the Bool.","category":"page"},{"location":"guide/inputs/#Inputs","page":"Inputs","title":"Inputs","text":"","category":"section"},{"location":"guide/pseudo/#Pseudo-Potentials","page":"Pseudo Potentials","title":"Pseudo Potentials","text":"","category":"section"},{"location":"guide/structure/#Structure","page":"Structure","title":"Structure","text":"","category":"section"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"EditURL = \"https://github.com/louisponet/DFControl.jl/blob/master/docs/src/guide/basic_tutorial.jl\"","category":"page"},{"location":"guide/basic_tutorial/#Basic-Tutorial","page":"Basic Tutorial","title":"Basic Tutorial","text":"","category":"section"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Since DFControl is aimed at improving the day to day quality of life of a material's scientist/anyone running DFT codes, we will look at a simple demonstration of how by creating and submitting some Quantum-Espresso calculations on Si starting from a cif file specifying the structure.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"using DFControl","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"First we download the cif file, extract the Structure and assign the right pseudos to it. In this case Si (F d -3 m :1) from http://www.crystallography.net/cod/9011998.cif","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"using Downloads\ncif_file = Downloads.download(\"http://www.crystallography.net/cod/9011998.cif\", \"Si.cif\")\n\nstructure = Structure(cif_file, name=\"Si\")\nset_pseudos!(structure, :pbesol)","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"This assumes that the :pbesol pseudopotential set was installed during the configuration step.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Next we specify the executables with which to run the QE calculations. We assume here that mpirun is installed and in the user's PATH, and that QE is installed, and to be found in the /opt/qe/bin, change this according to your own setup.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"pw_execs = [Exec(\"mpirun\", \"\", :np => 4), Exec(\"pw.x\", \"/opt/qe/bin/\", :nk => 4)]","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Additional executable flags can be passed as varargs to the constructor of Exec, e.g. Exec(\"pw.x\", \"/opt/qe/bin/\", :nk => 4, :ndiag => 2).","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Then we create the first input for our job, we name it scf, which will be used to reference it later. We also pass the executables to be used and additional flags to be set to the constructor. Afterwards we set the kpoints to be used in the scf calculation.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"scf_input = DFInput{QE}(\"scf\", pw_execs, :calculation => \"scf\")\nset_kpoints!(scf_input, (6,6,6,1,1,1))","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"The code recognizes internally that this 6-Tuple corresponds to a K_POINTS (automatic) block in QE. Alternatively (leading to an identical final result):","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"scf_input = DFInput{QE}(\"scf\", pw_execs, :calculation => \"scf\",\n                        data=[InputData(:k_points, :automatic, (6,6,6,1,1,1))])","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"We can now define our job:","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"job = DFJob(\"Si\", structure, [scf_input],\n            :ecutwfc => 20,\n            :conv_thr => 1e-6,\n            local_dir = \"job\")","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Additional inputs would be be added to the list [scf_input]. The flag => value pairs will set the specified flags to that value for all inputs in the job that allow recognize that flag, so it's ideal for things like cutoffs and smearing etc.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"We are now ready to submit the job, which will run in the current working directory","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"try #hide\nsubmit(job)\ncatch #hide\nglobal job = DFJob(joinpath(@__DIR__, \"../../src/assets/job/\"))#hide\npop!(job); #hide\nend #hide","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"This will generate and save all input files, and the corresponding job script (job.tt), and subsequently run the job. First submission through sbatch job.tt will be tried, if that fails then the script will run through bash job.tt.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"After the job finishes the outputs can be parsed through","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"outputdata(job)","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"or for a specific calculation","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"outputdata(job[\"scf\"])","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"This also demonstrates how a calculation can be referenced using its name (remember that we named the calculation \"scf\" when creating it).","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Now that the scf calculation finished succesfully, the next step is usually to have a look at the bandstructure. For this we generate a bands calculation, using the scf calculation as a template and a generated high symmetry k-point path with 20 kpoints per segment.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"bands_calc = gencalc_bands(job[\"scf\"], high_symmetry_kpath(job.structure, 20))","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Observe the :calculation => \"bands\", and automatic setting of the :verbosity => \"high\" flags. We now push! this calculation to the job queue","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"push!(job, bands_calc)","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"However, since we know the scf succeeded there is no need to rerun it. To un-schedule it we do","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"job[\"scf\"].run = false","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Printing the job will now highlight the scheduled calculations differently from the non-scheduled ones","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"job","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Seeing that all is right we submit the job again","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"set_localdir!(job, \"job\"); #hide\ntry #hide\nsubmit(job)\ncatch #hide\nglobal job = DFJob(joinpath(pathof(DFControl), \"..\",\"..\", \"docs\", \"src\", \"assets\", \"job\"));#hide\nend #hide","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"We can access the bands through","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"bands = readbands(job);\nnothing #hide","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"or","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"bands = outputdata(job[\"bands\"])[:bands];\nnothing #hide","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"They can be plotted too","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"fermi = readfermi(job) # = outputdata(job[\"scf\"])[:fermi]\nusing Plots\nplot(bands, fermi=fermi)","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Since more info (such as the structure) is available in the job, plotting the job leads to a richer plot","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"plot(job, -10, 1)","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"As can be seen in the Advanced Usage, additional information generated by additional calculations will be picked up by DFControl in order to create richer plots.","category":"page"},{"location":"guide/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"guide/installation/","page":"Installation","title":"Installation","text":"In case you don't have a working Julia installation yet, first download the Julia binaries and follow the Julia installation instructions. DFControl is tested thoroughly with Julia 1.6, your mileage may vary with older versions.","category":"page"},{"location":"guide/installation/","page":"Installation","title":"Installation","text":"Afterwards you can install DFControl like any other package in Julia. For example run in your Julia REPL terminal:","category":"page"},{"location":"guide/installation/","page":"Installation","title":"Installation","text":"import Pkg\nPkg.add(\"DFControl\")","category":"page"},{"location":"guide/installation/","page":"Installation","title":"Installation","text":"which will install the latest DFControl release. Alternatively (if you like to be fully up to date) install the master branch:","category":"page"},{"location":"guide/installation/","page":"Installation","title":"Installation","text":"import Pkg\nPkg.add(name=\"DFControl\", rev=\"master\")","category":"page"},{"location":"guide/installation/","page":"Installation","title":"Installation","text":"DFControl is continuously tested on Debian, Ubuntu, mac OS and Windows and should work on these operating systems out of the box.","category":"page"},{"location":"guide/installation/","page":"Installation","title":"Installation","text":"After these steps it is highly recommended to go through some additional Configuration.","category":"page"},{"location":"#DFControl","page":"Home","title":"DFControl","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The goal of DFControl is to alleviate some of the tedious day to day busy-work that material's scientists using DFT  codes encounter. It aids in the creation, execution, monitoring, management, and post-processing of DFT jobs.  The core framework is code-agnostic, however, many features are so far only implemented for Quantum-Espresso and Wannier90. Rudimentary support for ABINIT and ELK is also present.","category":"page"},{"location":"#Philosophy","page":"Home","title":"Philosophy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DFControl is aimed to be user friendly first and foremost, with features being added as time progresses without changing this core value. On the other hand, a core requirement has always been that power users that know all the ins and outs of the codes that they run should be able to have all the control they want without incurring friction from the library. DFControl therefore should never be a barrier to DFT code functionality, just a tool to increase efficiency of its users.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In light of this DFControl is structured to mimic the often adopted strategy of a linear submission script that specifies which input files  are ran with which DFT codes producing which outputs. Everything revolves around the DFJob that holds a collection of DFInputs which will be ran sequentially in the job's directory, on the job's crystal Structure. A DFJob is therefore identified with a specific directory. Using the script that is created upon saving or submitting a job, a DFJob can be easily reloaded at a later stage to continue the investigation where left off.","category":"page"},{"location":"#Highlighted-features","page":"Home","title":"Highlighted features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Creation and submission of a simple self-consistent-field calculation starting from a structure Cif file in less than 10 lines of code (see the Basic Tutorial])\nSeparation of Structure and DFInput so that the same DFInputs can be copied and used with a different Structure in a new job \nAutomatic validation and conversion of input flags\nTracking of jobs for ease of continuation at later times\nEase of input generation\nAutomatic plotting of available results using a single command\nInput flag sanity checks\nRudimentary job versioning to never lose previous job's results even if running in the same directory\nFully human readable and transparent job directory structure ","category":"page"},{"location":"guide/jobs/#Jobs","page":"Jobs","title":"Jobs","text":"","category":"section"},{"location":"guide/jobs/#Basics","page":"Jobs","title":"Basics","text":"","category":"section"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"A DFJob is a collection of DFInputs that can be scheduled to run or not in a linear fashion in the job's local_dir, using the Structure associated with the job. ","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"There are three ways of constructing a job:","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"DFJob(name::String, structure::Structure, inputs::Vector{DFInput}, input_flags::Pair{Symbol, Any}...; local_dir::String = \"\") - creates a new job \nDFJob(\"/abs/path/to/job/dir\") - loads a job from the specified path\nDFJob(\"<job dir fuzzy>\") - looks through the jobs known to DFControl (i.e. that were saved previously) and shows a menu allowing to select the desired one","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"A job can be saved through save(job), this will generate and save all the input files associated with each DFInput in the job, and subsequently save a job.tt submission script. job.local_dir can be inspected to get an idea of what these are.","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"submit will first save the job and then attempt to run the job script, first using sbatch job.tt followed by bash job.tt. ","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"The job script preamble is defined by a Vector{String} in job.header, which will be pasted as lines before the execution lines. This can be useful for specifying #SBATCH options, module load directives, export OMP_NUM_THREADS=1 environment variables, and similar.","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"To change a string inside one of the header lines, set_headerword!(job, \"string123\" => \"string124\") can be used, where any string that matches \"string123\" will be replaced by \"string124\".","category":"page"},{"location":"guide/jobs/#","page":"Jobs","title":"","text":"","category":"section"},{"location":"guide/configuration/#Configuration","page":"Configuration","title":"Configuration","text":"","category":"section"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"In order to not always have to respecify where to look for PseudoPotential sets,  they can be set up once and be remembered by DFControl.  This can be done through:","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"using DFControl\n\nsetdefault_pseudodir(:pseudo_set_name1, \"/absolute/path/to/pseudopotential/set/1\")\nsetdefault_pseudodir(:pseudo_set_name2, \"/absolute/path/to/pseudopotential/set/2\")\n\nconfiguredefault_pseudos()","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"This will go through the specified directories and find files that follow the naming convention element.x_y_z.xyz e.g. Si.pbesol-n-kjpaw_psl.0.1.UPF or si.pbesol-n-kjpaw_psl.0.1.UPF.  If multiple are found, all will be stored and the required one can be later specified. See Pseudo Potentials for further usage details.","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"In order to change the pseudos associated with a set name simply:","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"setdefault_pseudodir(:pseudo_set_name1, \"/new/absolute/path/to/pseudopotential/set/1\")\nsetdefault_pseudodir(:pseudo_set_name2, \"/new/absolute/path/to/pseudopotential/set/2\")\n\nconfiguredefault_pseudos()","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"In order to remove a default pseudo set one can run:","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"removedefault_pseudos(:pseudo_set_name)","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"After completing this configuration, it is suggested to look at the (Basic Usage)[@ref] for an introduction to the basic usage of DFControl.","category":"page"}]
}

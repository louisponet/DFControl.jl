var documenterSearchIndex = {"docs":
[{"location":"guide/flags/#Input-Flags","page":"Input Flags","title":"Input Flags","text":"","category":"section"},{"location":"guide/flags/","page":"Input Flags","title":"Input Flags","text":"Base.getindex(::DFJob, ::Symbol)\nBase.setindex!(::DFJob, ::Any, ::Symbol)","category":"page"},{"location":"guide/flags/#Base.getindex-Tuple{DFJob, Symbol}","page":"Input Flags","title":"Base.getindex","text":"getindex(job::DFJob, flag::Symbol)\n\nSearches through the job's inputs for the requested flag. A Dict will be returned with input names as the keys and the flags as values.\n\n\n\n\n\n","category":"method"},{"location":"guide/flags/#Base.setindex!-Tuple{DFJob, Any, Symbol}","page":"Input Flags","title":"Base.setindex!","text":"setindex!(job::DFJob, value, flag::Symbol)\n\nSet flag in all the appropriate inputs to the value.\n\n\n\n\n\n","category":"method"},{"location":"guide/flags/","page":"Input Flags","title":"Input Flags","text":"using DFControl #hide\njob = DFJob(joinpath(pathof(DFControl), \"..\", \"..\", \"docs\", \"src\", \"assets\", \"job\")) #hide\njob[:ecutwfc]\njob[:ecutwfc] = 40","category":"page"},{"location":"guide/structure/#Structure","page":"Structure","title":"Structure","text":"","category":"section"},{"location":"guide/jobs/#Jobs","page":"Jobs","title":"Jobs","text":"","category":"section"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"DFJob","category":"page"},{"location":"guide/jobs/#DFControl.DFJob","page":"Jobs","title":"DFControl.DFJob","text":"DFJob(name::String, structure::AbstractStructure;\n      inputs            ::Vector{DFInput} = DFInput[],\n      local_dir         ::String = pwd(),\n      header            ::Vector{String} = getdefault_jobheader(),\n      metadata          ::Dict = Dict(),\n      version           ::Int = last_job_version(local_dir),\n      copy_temp_folders ::Bool = false, \n      server            ::String = getdefault_server(),\n      server_dir        ::String = \"\")\n\nA DFJob embodies a set of calculations with inputs to be ran in directory local_dir, with the structure as the subject.\n\nKeywords/further attributes\n\ninputs: inputs to calculations that will be run sequentially.\nlocal_dir: the directory where the calculations will be run.\nheader: lines that will be pasted at the head of the job script, e.g. exports export OMP_NUM_THREADS=1, slurm settings#SBATCH, etc.\nmetadata: various additional information, will be saved in .metadata.jld2 in the local_dir.\nversion: the current version of the job.\ncopy_temp_folders: whether or not the temporary directory associated with intermediate calculation results should be copied when storing a job version. CAUTION These can be quite large.\nThe server and server_dir keywords should be avoided for the time being, as this functionality is not well tested.\n\nDFJob(job_name::String, structure::AbstractStructure, calculations::Vector{<:DFInput}, common_flags::Pair{Symbol, <:Any}...; kwargs...)\n\nCreates a new job. The common flags will be attempted to be set in each of the calculations. The kwargs... are passed to the DFJob constructor. \n\nDFJob(job_dir::String, job_script=\"job.tt\"; version=nothing, kwargs...)\n\nLoads the job in the local_dir. If job_dir is not a valid job path, the previously saved jobs will be scanned for a job with a local_dir that partly includes job_dir. If version is specified the corresponding job version will be returned if it exists.  The kwargs... will be passed to the DFJob constructor.\n\n\n\n\n\n","category":"type"},{"location":"guide/jobs/#Interacting-with-inputs","page":"Jobs","title":"Interacting with inputs","text":"","category":"section"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"Base.getindex(::DFJob, ::String)","category":"page"},{"location":"guide/jobs/#Base.getindex-Tuple{DFJob, String}","page":"Jobs","title":"Base.getindex","text":"getindex(job::DFJob, name::String)\n\nReturns the DFInput with the specified name.\n\ngetindex(job::DFJob, i::Integer)\n\nReturns the i'th DFInput in the job.\n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"using DFControl\njob = DFJob(joinpath(pathof(DFControl), \"..\", \"..\", \"docs\", \"src\", \"assets\", \"job\"))","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"Example: ","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"job[\"scf\"]\njob[2]","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"Base.push!(::DFJob, ::DFInput)\nBase.append!(::DFJob, ::Any...)\nBase.pop!(::DFJob)\nBase.insert!(::DFJob, ::Int, ::DFInput)","category":"page"},{"location":"guide/jobs/#Base.push!-Tuple{DFJob, DFInput}","page":"Jobs","title":"Base.push!","text":"push!(job::DFJob, input::DFInput)\n\npush!(job.inputs, input).\n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/#Base.append!-Tuple{DFJob, Vararg{Any, N} where N}","page":"Jobs","title":"Base.append!","text":"append!(job::DFJob, args...)\n\nappend!(job.inputs, args...).\n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/#Base.pop!-Tuple{DFJob}","page":"Jobs","title":"Base.pop!","text":"pop!(job::DFJob)\n\npop!(job.inputs).\n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/#Base.insert!-Tuple{DFJob, Int64, DFInput}","page":"Jobs","title":"Base.insert!","text":"insert!(job::DFJob, i::Int, input::DFInput) = insert!(job.inputs, i, input)\n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/#Scheduling,-submission-and-monitoring","page":"Jobs","title":"Scheduling, submission and monitoring","text":"","category":"section"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"set_flow!\nsave(::DFJob)\nsubmit\nisrunning\nlast_running_input\nabort","category":"page"},{"location":"guide/jobs/#DFControl.set_flow!","page":"Jobs","title":"DFControl.set_flow!","text":"set_flow!(job::DFJob, should_runs::Pair{String, Bool}...)\n\nSets whether or not calculations should be scheduled to run. The name of each input in the job will be checked against the string in each pair of should_runs, and the input.run will be set accordingly.\n\nExample:\n\nset_flow!(job, \"\" => false, \"scf\" => true)\n\nwould un-schedule all inputs in the job, and schedule the \"scf\" and \"nscf\" inputs to run.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#DFControl.save-Tuple{DFJob}","page":"Jobs","title":"DFControl.save","text":"save(job::DFJob)\n\nSaves the job's inputs and job.tt submission script in job.local_dir. Some sanity checks will be performed on the validity of flags, execs, pseudopotentials, etc. The job will also be registered for easy retrieval at a later stage.\n\nIf a previous job is present in the job directory (indicated by a valid job script), it will be copied to the .versions sub directory as the previous version of job, and the version of job will be incremented. \n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/#DFControl.submit","page":"Jobs","title":"DFControl.submit","text":"submit(job::DFJob; kwargs...)\n\nFirst saves the job, then tries to submit the job script through sbatch job.tt or bash job.tt if the former command fails. kwargs... get passed to save(job; kwargs...).\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#DFControl.isrunning","page":"Jobs","title":"DFControl.isrunning","text":"isrunning(job::DFJob; print=true)\n\nIf the job was submitted through a scheduler like slurm, this will return whether the job is queued or running.\n\nNote: For now only slurm is supported as scheduler.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#DFControl.last_running_input","page":"Jobs","title":"DFControl.last_running_input","text":"last_running_input(job::DFJob)\n\nReturns the last DFInput for which an output file was created.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#DFControl.abort","page":"Jobs","title":"DFControl.abort","text":"abort(job::DFJob)\n\nWill try to remove the job from the scheduler's queue. If the last running input happened to be a DFInput{QE}, the correct abort file will be written. For other codes the process is not smooth, and restarting is not guaranteed.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#Management","page":"Jobs","title":"Management","text":"","category":"section"},{"location":"guide/jobs/#Directories","page":"Jobs","title":"Directories","text":"","category":"section"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"set_localdir!(::DFJob, ::String)\nBase.cp(::DFJob, ::String)\nBase.mv(::DFJob, ::String)\nBase.filesize\nBase.joinpath(::DFJob, ::Any...)\ncleanup","category":"page"},{"location":"guide/jobs/#DFControl.set_localdir!-Tuple{DFJob, String}","page":"Jobs","title":"DFControl.set_localdir!","text":"set_localdir!(job::DFJob, dir::String; copy=false)\n\nSets job.local_dir to dir. If necessary the directory will be created. If copy is set to true, all previous inputs and output files of the current job version (i.e. those in the main job directory) will be copied to the new directory, including the outputs directory with temporary files created during jobs runs.\n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/#Base.Filesystem.cp-Tuple{DFJob, String}","page":"Jobs","title":"Base.Filesystem.cp","text":"cp(job::DFJob, dest::String; all=false, temp=false, kwargs...)\n\nCopies the contents of job.local_dir to dest. If all=true, it will also copy the .version directory with all previous versions. If temp=true it will override job.copy_temp_folders and copy also the temporary calculation directories. The kwargs... are passed to Base.cp.\n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/#Base.Filesystem.mv-Tuple{DFJob, String}","page":"Jobs","title":"Base.Filesystem.mv","text":"mv(job::DFJob, dest::String; all=false, temp=false, kwargs...)\n\nMoves the contents of job.local_dir to dest. If all=true, it will also move the .version directory with all previous versions. If temp=true it will override job.copy_temp_folders and move also the temporary calculation directories. The kwargs... are passed to Base.mv.\n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/#Base.filesize","page":"Jobs","title":"Base.filesize","text":"filesize(job::DFJob)\n\nTotal filesize on disk for a job and all its versions.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#Base.Filesystem.joinpath-Tuple{DFJob, Vararg{Any, N} where N}","page":"Jobs","title":"Base.Filesystem.joinpath","text":"joinpath(job::DFJob, args...)\n\njoinpath(job.local_dir, args...).\n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/#DFControl.cleanup","page":"Jobs","title":"DFControl.cleanup","text":"cleanup(job::DFJob)\n\nCleanup job.local_dir interactively.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#Versioning","page":"Jobs","title":"Versioning","text":"","category":"section"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"As previously mentioned, a rudimentary implementation of a DFJob versioning system is implemented.  Upon calling save on a DFJob, if there is already a valid job script present in job.local_dir,  it is assumed that this was a previous version of the job and the script together with all other files in job.local_dir will be copied to a subdirectory of the .versions directory bearing the name of the  respective previous job version. After this, job.version will be incremented by 1 signalling the  new version of the current job. ","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"The virtue of this system is that it is possible to roll back to a previous version after possibly making breaking changes, or to pull out previous results after further experimentation was performed.","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"note: Note\nIf job.copy_temp_folders=true all possible intermediate files inside the temporary calculation directory  (i.e. \"job_dir/outputs\") will be copied every time the job is saved. These can be quite large and  can quickly create very large job directories. Handle with care!","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"versions\nswitch_version\nrm_version!","category":"page"},{"location":"guide/jobs/#DFControl.versions","page":"Jobs","title":"DFControl.versions","text":"versions(job::DFJob)\n\nReturs the valid versions of job.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#DFControl.switch_version","page":"Jobs","title":"DFControl.switch_version","text":"switch_version(job::DFJob, version::Int)\n\nSwitches the version of job to one of the previously stored ones. It will save also the current version for future reference.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#DFControl.rm_version!","page":"Jobs","title":"DFControl.rm_version!","text":"rm_version!(job::DFJob, version::Int)\nrm_versions!(job::DFJob, versions::Int...)\n\nRemoves the specified versions from the job if they exists.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"More functionality related to versioning will be added in the future.","category":"page"},{"location":"guide/pseudo/#Pseudo-Potentials","page":"Pseudo Potentials","title":"Pseudo Potentials","text":"","category":"section"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"EditURL = \"https://github.com/louisponet/DFControl.jl/blob/master/docs/src/guide/basic_tutorial.jl\"","category":"page"},{"location":"guide/basic_tutorial/#Basic-Tutorial","page":"Basic Tutorial","title":"Basic Tutorial","text":"","category":"section"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Since DFControl is aimed at improving the day to day quality of life of a material's scientist/anyone running DFT codes, we will look at a simple demonstration of how by creating and submitting some Quantum-Espresso calculations on Si starting from a cif file specifying the structure.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"using DFControl","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"First we download the cif file, extract the Structure and assign the right pseudos to it. In this case Si (F d -3 m :1) from http://www.crystallography.net/cod/9011998.cif","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"using Downloads\ncif_file = Downloads.download(\"http://www.crystallography.net/cod/9011998.cif\", \"Si.cif\")\n\nstructure = Structure(cif_file, name=\"Si\")\nset_pseudos!(structure, :pbesol)","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"This assumes that the :pbesol pseudopotential set was installed during the configuration step.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Next we specify the executables with which to run the QE calculations. We assume here that mpirun is installed and in the user's PATH, and that QE is installed, and to be found in the /opt/qe/bin, change this according to your own setup.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"pw_execs = [Exec(\"mpirun\", \"\", :np => 4), Exec(\"pw.x\", \"/opt/qe/bin/\", :nk => 4)]","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Additional executable flags can be passed as varargs to the constructor of Exec, e.g. Exec(\"pw.x\", \"/opt/qe/bin/\", :nk => 4, :ndiag => 2).","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Then we create the first input for our job, we name it scf, which will be used to reference it later. We also pass the executables to be used and additional flags to be set to the constructor. Afterwards we set the kpoints to be used in the scf calculation.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"scf_input = DFInput{QE}(\"scf\", :calculation => \"scf\", execs=pw_execs)\nset_kpoints!(scf_input, (6,6,6,1,1,1))","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"The code recognizes internally that this 6-Tuple corresponds to a K_POINTS (automatic) block in QE. Alternatively (leading to an identical final result):","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"scf_input = DFInput{QE}(\"scf\", :calculation => \"scf\",\n                        execs=pw_execs,\n                        data=[InputData(:k_points, :automatic, (6,6,6,1,1,1))])","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"We can now define our job:","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"job = DFJob(\"Si\", structure, [scf_input],\n            :ecutwfc => 20,\n            :conv_thr => 1e-6,\n            local_dir = \"job\")","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Additional inputs would be be added to the list [scf_input]. The flag => value pairs will set the specified flags to that value for all inputs in the job that allow recognize that flag, so it's ideal for things like cutoffs and smearing etc.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"We are now ready to submit the job, which will run in the current working directory","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"try #hide\nsubmit(job)\ncatch #hide\nglobal job = DFJob(joinpath(@__DIR__, \"../../src/assets/job/\"))#hide\npop!(job); #hide\nend #hide","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"This will generate and save all input files, and the corresponding job script (job.tt), and subsequently run the job. First submission through sbatch job.tt will be tried, if that fails then the script will run through bash job.tt.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"After the job finishes the outputs can be parsed through","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"outputdata(job)","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"or for a specific calculation","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"outputdata(job[\"scf\"])","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"This also demonstrates how a calculation can be referenced using its name (remember that we named the calculation \"scf\" when creating it).","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Now that the scf calculation finished succesfully, the next step is usually to have a look at the bandstructure. For this we generate a bands calculation, using the scf calculation as a template and a generated high symmetry k-point path with 20 kpoints per segment.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"bands_calc = gencalc_bands(job[\"scf\"], high_symmetry_kpath(job.structure, 20))","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Observe the :calculation => \"bands\", and automatic setting of the :verbosity => \"high\" flags. We now push! this calculation to the job queue","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"push!(job, bands_calc)","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"However, since we know the scf succeeded there is no need to rerun it. To un-schedule it we do","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"job[\"scf\"].run = false","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Printing the job will now highlight the scheduled calculations differently from the non-scheduled ones","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"job","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Seeing that all is right we submit the job again","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"set_localdir!(job, \"job\"); #hide\ntry #hide\nsubmit(job)\ncatch #hide\nglobal job = DFJob(joinpath(pathof(DFControl), \"..\",\"..\", \"docs\", \"src\", \"assets\", \"job\"));#hide\nend #hide","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"We can access the bands through","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"bands = readbands(job);\nnothing #hide","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"or","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"bands = outputdata(job[\"bands\"])[:bands];\nnothing #hide","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"They can be plotted too","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"fermi = readfermi(job) # = outputdata(job[\"scf\"])[:fermi]\nusing Plots\nplot(bands, fermi=fermi)","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Since more info (such as the structure) is available in the job, plotting the job leads to a richer plot","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"plot(job, -10, 1)","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"As can be seen in the Advanced Usage, additional information generated by additional calculations will be picked up by DFControl in order to create richer plots.","category":"page"},{"location":"guide/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"guide/installation/","page":"Installation","title":"Installation","text":"In case you don't have a working Julia installation yet, first download the Julia binaries and follow the Julia installation instructions. DFControl is tested thoroughly with Julia 1.6, your mileage may vary with older versions.","category":"page"},{"location":"guide/installation/","page":"Installation","title":"Installation","text":"Afterwards you can install DFControl like any other package in Julia. For example run in your Julia REPL terminal:","category":"page"},{"location":"guide/installation/","page":"Installation","title":"Installation","text":"import Pkg\nPkg.add(\"DFControl\")","category":"page"},{"location":"guide/installation/","page":"Installation","title":"Installation","text":"which will install the latest DFControl release. Alternatively (if you like to be fully up to date) install the master branch:","category":"page"},{"location":"guide/installation/","page":"Installation","title":"Installation","text":"import Pkg\nPkg.add(name=\"DFControl\", rev=\"master\")","category":"page"},{"location":"guide/installation/","page":"Installation","title":"Installation","text":"DFControl is continuously tested on Debian, Ubuntu, mac OS and Windows and should work on these operating systems out of the box.","category":"page"},{"location":"guide/installation/","page":"Installation","title":"Installation","text":"After these steps it is highly recommended to go through some additional Configuration.","category":"page"},{"location":"guide/configuration/#Configuration","page":"Configuration","title":"Configuration","text":"","category":"section"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"In order to not always have to respecify where to look for PseudoPotential sets,  they can be set up once and be remembered by DFControl.  This can be done through:","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"using DFControl\n\nsetdefault_pseudodir(:pseudo_set_name1, \"/absolute/path/to/pseudopotential/set/1\")\nsetdefault_pseudodir(:pseudo_set_name2, \"/absolute/path/to/pseudopotential/set/2\")\n\nconfiguredefault_pseudos()","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"This will go through the specified directories and find files that follow the naming convention element.x_y_z.xyz e.g. Si.pbesol-n-kjpaw_psl.0.1.UPF or si.pbesol-n-kjpaw_psl.0.1.UPF.  If multiple are found, all will be stored and the required one can be later specified. See Pseudo Potentials for further usage details.","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"In order to change the pseudos associated with a set name simply:","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"setdefault_pseudodir(:pseudo_set_name1, \"/new/absolute/path/to/pseudopotential/set/1\")\nsetdefault_pseudodir(:pseudo_set_name2, \"/new/absolute/path/to/pseudopotential/set/2\")\n\nconfiguredefault_pseudos()","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"In order to remove a default pseudo set one can run:","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"removedefault_pseudos(:pseudo_set_name)","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"After completing this configuration, it is suggested to look at the (Basic Usage)[@ref] for an introduction to the basic usage of DFControl.","category":"page"},{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"This page provides a plain list of all inline documention associated with functions, structs  and macros in DFControl. Note that this list is neither structured, complete nor particularly clean, so it only provides rough orientation at the moment. The best reference is the code itself.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"EditURL = \"https://github.com/louisponet/DFControl.jl/blob/master/docs/src/guide/advanced_tutorial.jl\"","category":"page"},{"location":"guide/advanced_tutorial/#Advanced-Usage","page":"Advanced Tutorial","title":"Advanced Usage","text":"","category":"section"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"In this tutorial we will continue from the job created in the Basic Tutorial, and demonstrate some more advanced functionality that DFControl offers.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"To load a previously saved job we here provide a valid job directory with a job.tt script in it.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"using DFControl\n\ntjob = DFJob(joinpath(pathof(DFControl), \"..\",\"..\",\"docs\", \"src\", \"assets\", \"job\"))#hide\ntjob2 = DFJob(joinpath(pathof(DFControl), \"..\",\"..\", \"docs\", \"src\", \"assets\", \"Job2\"))#hide\ntry#hide\nglobal job = DFJob(\"job\")\ncatch#hide\nglobal job = deepcopy(tjob)#hide\nset_localdir!(job, \"job\"); #hide\njob#hide\nend#hide","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Since the job created in the Basic Tutorial was saved in the \"job\" directory this will work, see the section on Jobs for further details and options on how to load previously saved jobs.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"The next thing we may want to do is to change the directory where the job is running.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"try#hide\nset_localdir!(job, \"Job2\", copy=true)\ncatch#hide\nglobal job = deepcopy(tjob2);#hide\npop!(job);#hide\npop!(job);#hide\njob#hide\nend#hide","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"With the copy=true flag we let DFControl know that not only to create and set the new directory, but also to copy the previous results and temporary files to the new directory so we don't have to rerun the scf calculation.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Next we would like to plot the projected density of states. For that we create both an nscf calculation to get a uniform k-grid, and projwfc input.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"push!(job, gencalc_nscf(job[\"scf\"], (6,6,6)))","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"The second argument of gencalc_nscf is the kgrid. When passing a 3-Tuple, the code will assume that an explicit k-grid is requested, which can be verified by","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"data(job[\"nscf\"], :k_points)","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Next we generate a projwfc input using the fermi level as a guide for the energy window. The arguments are structured as (template, Emin, Emax, deltaE) respectively.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"fermi = readfermi(job)\npush!(job, gencalc_projwfc(job[\"nscf\"], fermi-10, fermi+1, 0.1))","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Next we disable the bands calculation, run the new ones, and plot the results","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"job[\"bands\"].run = false\ntry#hide\nsubmit(job)\ncatch#hide\nglobal job = deepcopy(tjob2)#hide\nend#hide\nusing Plots\nplot(job, -10, 1)","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"As we can see, again DFControl identifies the additional information that is now present in the job, and uses it to display in the plot.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"In the demonstrated case we see that everything went according to plan, however, often things need to be changed in a trial and error way until the desired results are found.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"On common occurence is that input flags have to be set, or changed. This can be done in two ways","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"job[:ecutwfc] = 40.0","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"will go through all the inputs of the job and set the flag if it is allowed, i.e. the flag will not be set in the projwfc input since it makes no sense.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"job[\"bands\"][:nbnd] = 30","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"This will set a flag for one specific calculation, again checking whether the flag is valid, and the type will be converted to the correct one.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"In order to quickly specify what calculations to schedule and which not, one can use","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"set_flow!(job, \"\" => false, \"scf\" => true)","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"As we can see, only the scf and nscf calculations are scheduled to run now, this is because for each of the pairs in the arguments of set_flow!, every input inside the job for which the string occurs in the name will be set to run or not depending on the Bool.","category":"page"},{"location":"guide/execs/#Execs","page":"Execs","title":"Execs","text":"","category":"section"},{"location":"guide/execs/","page":"Execs","title":"Execs","text":"set_execdir!(::DFJob, ::String, ::String)","category":"page"},{"location":"guide/execs/#DFControl.set_execdir!-Tuple{DFJob, String, String}","page":"Execs","title":"DFControl.set_execdir!","text":"set_execdir!(job::DFJob, exec::String, dir::String)\n\nGoes through all the executables that are present in the inputs of the job, if the executable matches exec, its directory will be set to dir.\n\nset_execdir!(job, \"pw.x\", \"/path/to/QE/bin\")\n\nset_execdir!(input::DFInput, exec::String, dir::String)\n\nGoes through the executables that are present in the input, if the executable matches exec, its directory will be set to dir.\n\nset_execdir!(input, \"pw.x\", \"/path/to/QE/bin\")\n\n\n\n\n\n","category":"method"},{"location":"guide/inputs/#Inputs","page":"Inputs","title":"Inputs","text":"","category":"section"},{"location":"guide/inputs/","page":"Inputs","title":"Inputs","text":"DFInput","category":"page"},{"location":"guide/inputs/#DFControl.DFInput","page":"Inputs","title":"DFControl.DFInput","text":"DFInput{P<:Package}(name     ::String;\n                    dir      ::String = \"\",\n                    flags    ::AbstractDict = Dict{Symbol, Any}(),\n                    data     ::Vector{InputData} = InputData[],\n                    execs    ::Vector{Exec},\n                    run      ::Bool = true,\n                    outdata  ::AbstractDict = Dict{Symbol, Any}(),\n                    infile   ::String = P == Wannier90 ? name * \".win\" : name * \".in\",\n                    outfile  ::String = name * \".out\")\n\nA full representation of a DFT calculation of package P, holding the flags that will be written to the infile, the executables in execs and the output written by the calculation to the outfile. outdata stores the parsed calculation output after it was read at least once. The run field indicates whether the calculation should be actually performed, e.g. if run=false the corresponding line will be commented out in the job script.\n\nDFInput{P<:Package}(name::AbstractString, flags::Pair{Symbol, Any}...; kwargs...)\n\nCreate a DFInput from name and flags, other kwargs... will be passed to the constructor.\n\nDFInput(template::DFInput, name::AbstractString, flags::Pair{Symbol, Any}...; excs=deepcopy(execs(template)), run=true, data=nothing, dir=copy(template.dir))\n\nCreates a new DFInput from the template, setting the flags of the newly created one to the specified ones.\n\n\n\n\n\n","category":"type"},{"location":"#DFControl","page":"Home","title":"DFControl","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The goal of DFControl is to alleviate some of the tedious day to day busy-work that material's scientists using DFT  codes encounter. It aids in the creation, execution, monitoring, management, and post-processing of DFT jobs.  The core framework is code-agnostic, however, many features are so far only implemented for Quantum-Espresso and Wannier90. Rudimentary support for ABINIT and ELK is also present.","category":"page"},{"location":"#Philosophy","page":"Home","title":"Philosophy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DFControl is aimed to be user friendly first and foremost, with features being added as time progresses without changing this core value. On the other hand, a core requirement has always been that power users that know all the ins and outs of the codes that they run should be able to have all the control they want without incurring friction from the library. DFControl therefore should never be a barrier to DFT code functionality, just a tool to increase efficiency of its users.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In light of this DFControl is structured to mimic the often adopted strategy of a linear submission script that specifies which input files  are ran with which DFT codes producing which outputs. Everything revolves around the DFJob that holds a collection of DFInputs which will be ran sequentially in the job's directory, on the job's crystal Structure. A DFJob is therefore identified with a specific directory. Using the script that is created upon saving or submitting a job, a DFJob can be easily reloaded at a later stage to continue the investigation where left off.","category":"page"},{"location":"#Highlighted-features","page":"Home","title":"Highlighted features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Creation and submission of a simple self-consistent-field calculation starting from a structure Cif file in less than 10 lines of code (see the Basic Tutorial])\nSeparation of Structure and DFInput so that the same DFInputs can be copied and used with a different Structure in a new job \nAutomatic validation and conversion of input flags\nTracking of jobs for ease of continuation at later times\nEase of input generation\nAutomatic plotting of available results using a single command\nInput flag sanity checks\nRudimentary job versioning to never lose previous job's results even if running in the same directory\nFully human readable and transparent job directory structure ","category":"page"}]
}

var documenterSearchIndex = {"docs":
[{"location":"guide/flags/#Flags","page":"Flags","title":"Flags","text":"","category":"section"},{"location":"guide/structure/#Structure","page":"Structure","title":"Structure","text":"","category":"section"},{"location":"guide/structure/#Contents","page":"Structure","title":"Contents","text":"","category":"section"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"Pages=[\"structure.md\"]","category":"page"},{"location":"guide/structure/#Index","page":"Structure","title":"Index","text":"","category":"section"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"Pages=[\"structure.md\"]","category":"page"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"Structure\nBase.getindex(::Structure, ::Int)\nStructures.update_geometry!\nStructures.polyhedron","category":"page"},{"location":"guide/structure/#DFControl.Structures.Structure","page":"Structure","title":"DFControl.Structures.Structure","text":"Structure(cell::Mat3, atoms::Vector{Atom})\n\nThe structure on which the Calculations will be performed.\n\nStructure(cif_file::String)\n\nCreates a Structure from the supplied cif file.\n\n\n\n\n\n","category":"type"},{"location":"guide/structure/#Base.getindex-Tuple{Structure, Int64}","page":"Structure","title":"Base.getindex","text":"getindex(structure::Structure, i::Int)\ngetindex(structure::Structure, name::Symbol)\ngetindex(structure::Structure, el::Element)\n\nReturns the ith atom in structure, or all atoms with name or are of element el.\n\n\n\n\n\n","category":"method"},{"location":"guide/structure/#DFControl.Structures.update_geometry!","page":"Structure","title":"DFControl.Structures.update_geometry!","text":"update_geometry!(str1::Structure, str2::Structure)\n\nUpdates the spatial parameters of the atoms and cell of the first structure to those found in the second.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFControl.Structures.polyhedron","page":"Structure","title":"DFControl.Structures.polyhedron","text":"polyhedron(at::Atom, atoms::Vector{Atom}, order::Int)\npolyhedron(at::Atom, str::Structure, order::Int)\n\nReturns a polyhedron around the atom, i.e. the order closest atoms. The returned atoms will be ordered according to their distance to the first one. In the case of a structure rather than a set of atoms, the search will be performed over all atoms in the structure.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#Symmetries","page":"Structure","title":"Symmetries","text":"","category":"section"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"This functionality relies on spglib to find the symmetries of the Structure and  supply various related quantities.","category":"page"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"Structures.high_symmetry_kpath\nStructures.high_symmetry_kpoints\nStructures.international\nStructures.niggli_reduce\nStructures.symmetry_operators","category":"page"},{"location":"guide/structure/#DFControl.Structures.high_symmetry_kpath","page":"Structure","title":"DFControl.Structures.high_symmetry_kpath","text":"high_symmetry_kpath(s::Structure, npoints_per_segment::Int; package=QE, kwargs...)\n\nGenerates a QE bands calculation compliant high symmetry kpath, to be used with e.g. set_kpoints!(bands_calculation, kpoints). \n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFControl.Structures.high_symmetry_kpoints","page":"Structure","title":"DFControl.Structures.high_symmetry_kpoints","text":"high_symmetry_kpoints(s::Structure; tolerance = 1e-5)\n\nReturns (kpoints, path) where kpoints are the high-symmetry k-points, and path are the sections of the high symmetry path through the first Brillouin Zone.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFControl.Structures.international","page":"Structure","title":"DFControl.Structures.international","text":"international(s::Structure; tolerance=1.0e-5)\n\nReturns the international symbol of the space group of the structure.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFControl.Structures.niggli_reduce","page":"Structure","title":"DFControl.Structures.niggli_reduce","text":"niggli_reduce(s::Structure; tolerance=1.0e-5)\n\nReturns the niggli reduced Structure.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFControl.Structures.symmetry_operators","page":"Structure","title":"DFControl.Structures.symmetry_operators","text":"symmetry_operators(s::Structure; maxsize=52, tolerance=1.0e-5)\n\nFinds and returns all the rotations and translations that are symmetry operators of the structure.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#Cell","page":"Structure","title":"Cell","text":"","category":"section"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"note: Note\nThe lattice vectors are stored as the columns of the cell.","category":"page"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"Structures.a\nStructures.b\nStructures.c\nStructures.cell_parameters\nStructures.volume\nStructures.create_supercell\nStructures.scale_cell!","category":"page"},{"location":"guide/structure/#DFControl.Structures.a","page":"Structure","title":"DFControl.Structures.a","text":"a(str::Structure)\n\nFirst lattice vector.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFControl.Structures.b","page":"Structure","title":"DFControl.Structures.b","text":"b(str::Structure)\n\nSecond lattice vector.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFControl.Structures.c","page":"Structure","title":"DFControl.Structures.c","text":"c(str::Structure)\n\nThird lattice vector.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFControl.Structures.cell_parameters","page":"Structure","title":"DFControl.Structures.cell_parameters","text":"cell_parameters(cell::Mat3)\ncell_parameters(str::Structure)\n\nParameters (a, b, c, α, β, γ)of the calculation cell returned in a NamedTuple.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFControl.Structures.volume","page":"Structure","title":"DFControl.Structures.volume","text":"volume(cell::Mat3)\nvolume(str::Structure)\n\nCalculates the volume for the unit cell.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFControl.Structures.create_supercell","page":"Structure","title":"DFControl.Structures.create_supercell","text":"create_supercell(structure::Structure, na::Int, nb::Int, nc::Int; make_afm=false)\ncreate_supercell(structure::Structure, na::UnitRange, nb::UnitRange, nc::UnitRange; make_afm=false)\n\nTakes a structure and creates a supercell from it with: the given amount of additional cells if (na::Int, nb::Int, nc::Int) along the a, b, c direction, or amount of cells specified by the ranges i.e. -1:1, -1:1, -1:1 would create a 3x3x3 supercell. If make_afm is set to true all the labels and magnetizations of the magnetic atoms will be reversed in a checkerboard fashion.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFControl.Structures.scale_cell!","page":"Structure","title":"DFControl.Structures.scale_cell!","text":"scale_cell!(structure::Structure, scalemat::Matrix)\n\nRescales the cell of the structure.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#Atom","page":"Structure","title":"Atom","text":"","category":"section"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"Atom\nStructures.set_position!","category":"page"},{"location":"guide/structure/#DFControl.Structures.Atom","page":"Structure","title":"DFControl.Structures.Atom","text":"Atom(name::Symbol, element::Element, position_cart::Point3{Length}, position_cryst::Point3;\n     pseudo::String = \"\",\n     projections::Vector{Projection} = Projection[],\n     magnetization::Vec3 = Vec3(0.0, 0.0, 0.0),\n     dftu::DFTU = DFTU())\n\nRepresentation of an atom.\n\nThe name of the atom is used as an identifier for the atom type, in the sense that atoms with the same pseudo, projections, magnetization and dftu attributes should belong to the same type. This also means that during sanity checks atoms that are not of the same type will be given different names. This is done in this way because it often makes sense to change these parameters on all atoms of the same kind at the same time, but still allow the flexibility to change them for individual atoms as well.\n\nposition_cart should have a valid Unitful.Length type such as Ang.\n\nSee documentation for Element for further information on this attribute.\n\n\n\n\n\n","category":"type"},{"location":"guide/structure/#DFControl.Structures.set_position!","page":"Structure","title":"DFControl.Structures.set_position!","text":"set_position!(at::Atom, pos::AbstractVector{T}, unit_cell::Mat3) where {T<:Real}\n\nUpdates the position of the atom to this. The unit cell is used to make sure both position_cryst and position_cart are correct.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#Element","page":"Structure","title":"Element","text":"","category":"section"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"Structures.Element\nelement","category":"page"},{"location":"guide/structure/#DFControl.Structures.Element","page":"Structure","title":"DFControl.Structures.Element","text":"Element(symbol::Symbol, Z::Int, name::String, atomic_weight::Float64, color::NTuple{3, Float64})\n\nRepresents an element. Most conveniently used trough the function element.\n\n\n\n\n\n","category":"type"},{"location":"guide/structure/#DFControl.Structures.element","page":"Structure","title":"DFControl.Structures.element","text":"element(sym::Symbol)\n\nReturns the predefined Element with symbol sym, i.e. element(:Si) will return the pregenerated Silicon Element.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#pseudo_header","page":"Structure","title":"Pseudo Potentials","text":"","category":"section"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"set_pseudos!\nconfigure_pseudoset\nlist_pseudosets","category":"page"},{"location":"guide/structure/#DFControl.Structures.set_pseudos!","page":"Structure","title":"DFControl.Structures.set_pseudos!","text":"set_pseudos!(job::Job, set::String; server=job.server, specifier::String=\"\", kwargs...)\nset_pseudos!(structure::Structure, set::String; server=\"localhost\", specifier::String=\"\", kwargs...)\n\nSets the pseudopotentials of the atoms inside the structure (or job.structure) to the ones of set. specifier can be specified as a fuzzy match to select a specific pseudos if multiple pseudopotentials exist in the set. Example:\n\nset_pseudos!(job, \"pbesol\", specifier=\"rrkjus\")\n\nwill select the pseudo file that contains \"rrkjus\" in the filename.\n\nThe pseudos will be searched for in the server.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"See the section on Configuration for a demonstration on how to set up pseudopotential sets.","category":"page"},{"location":"guide/structure/#Magnetization","page":"Structure","title":"Magnetization","text":"","category":"section"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"Magnetization can be set on a per Atom basis. It will partially determine the unique Atom types and also what calculation flags should be set in order to allow for the  magnetic calculation (either colinear or non-colinear).","category":"page"},{"location":"guide/structure/#Projections","page":"Structure","title":"Projections","text":"","category":"section"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"These projections will mainly be used for generating Wannier90 inputs, and to distinguish which indices in the Wannier90 output matrices correspond to the various atoms/orbitals.","category":"page"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"Projection","category":"page"},{"location":"guide/structure/#DFControl.Structures.Projection","page":"Structure","title":"DFControl.Structures.Projection","text":"Projection(orbital::Orbital, start::Int, last::Int)\n\nA Wannier90 Projection, representing an Orbital with indices from start to last.\n\n\n\n\n\n","category":"type"},{"location":"guide/structure/#Orbitals","page":"Structure","title":"Orbitals","text":"","category":"section"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"Structures.Orbital","category":"page"},{"location":"guide/structure/#DFControl.Structures.Orbital","page":"Structure","title":"DFControl.Structures.Orbital","text":"Orbital(name::String, size::Int, l::Int, mr::Int)\n\nWannier90 orbital as defined in the Wannier90 User Guide. The name will be written in the projections block of the Wannier90 input.\n\n\n\n\n\n","category":"type"},{"location":"guide/structure/#DFT-U","page":"Structure","title":"DFT + U","text":"","category":"section"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"DFTU","category":"page"},{"location":"guide/structure/#DFControl.Structures.DFTU","page":"Structure","title":"DFControl.Structures.DFTU","text":"DFTU(;l ::Int = -1,\n      U ::T   = zero(T),\n      J0::T  = zero(T),\n      α ::T   = zero(T),\n      β ::T   = zero(T),\n      J ::Vector{T} = T[zero(T)])\n\nDFT+U parameters for a given Atom.\n\n\n\n\n\n","category":"type"},{"location":"guide/servers/#servers_header","page":"Servers","title":"Servers","text":"","category":"section"},{"location":"guide/servers/","page":"Servers","title":"Servers","text":"DFControl is structure as a client-server architecture where the communication happens through a rest-API. This means that on the server-side a small daemon will run that the client will communicate with in order to load, save and submit Jobs. There are three ways to set up a server. To setup a local server, simply call Servers.configure_local and follow the prompt. A Server can also be setup by calling the constructor with a String that signifies the name of the Server, e.g. \"localhost\", or an ssh string such as \"user@domain\", which will prompt an interactive setup menu. ","category":"page"},{"location":"guide/servers/","page":"Servers","title":"Servers","text":"Alternatively, for full customization, a Server can be set up by filling out the constructor, and saving it as save(server). A previously saved Server can be loaded again through e.g. Server(\"localhost\") which will retrieve the previously saved configuration.","category":"page"},{"location":"guide/servers/","page":"Servers","title":"Servers","text":"Server\nServers.configure_local\nstart\nsave(::Server)","category":"page"},{"location":"guide/servers/#DFControl.Servers.Server","page":"Servers","title":"DFControl.Servers.Server","text":"Server(name::String, username::String, domain::String, port::Int, scheduler::Scheduler, mountpoint::String,\n       julia_exec::String, root_jobdir::String, local_port::Int, max_concurrent_jobs::Int)\nServer(name::String)\n\nA Server represents a remote daemon that has the label name. It runs on the server defined by username and domain. The requirement is that ssh is set up in such a way that ssh username@domain is possible, i.e. ssh-copy-id must have been used to not require passwords while executing ssh commands.\n\nThe daemon will listen to the port for http requests and if local_port is specified, a tunnel will be created to guarantee a connection. This is useful in the case that the login node on the remote server can change.\n\nCalling Server with a single String will either load the configuration that was previously saved with that label, or go through an interactive setup of a new server.\n\n\n\n\n\n","category":"type"},{"location":"guide/servers/#DFControl.Servers.configure_local","page":"Servers","title":"DFControl.Servers.configure_local","text":"configure_local()\n\nRuns through interactive configuration of the local Server.\n\n\n\n\n\n","category":"function"},{"location":"guide/servers/#DFControl.Servers.start","page":"Servers","title":"DFControl.Servers.start","text":"start(s::Server)\n\nLaunches the daemon process on  the host Server s.\n\n\n\n\n\n","category":"function"},{"location":"guide/servers/#DFControl.Database.save-Tuple{Server}","page":"Servers","title":"DFControl.Database.save","text":"save([server::Server], e::Environment)\nsave([server::Server], e::Exec)\nsave([server::Server], s::Server)\n\nSaves an item to the database of server. If server is not specified the item will be stored in the local database.\n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/#Jobs","page":"Jobs","title":"Jobs","text":"","category":"section"},{"location":"guide/jobs/#Contents","page":"Jobs","title":"Contents","text":"","category":"section"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"Pages=[\"jobs.md\"]","category":"page"},{"location":"guide/jobs/#Index","page":"Jobs","title":"Index","text":"","category":"section"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"Pages=[\"jobs.md\"]","category":"page"},{"location":"guide/jobs/#Job","page":"Jobs","title":"Job","text":"","category":"section"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"Job\nload(::Server, ::Job)","category":"page"},{"location":"guide/jobs/#DFControl.Jobs.Job","page":"Jobs","title":"DFControl.Jobs.Job","text":"Job(name::String, structure::Structure;\n      calculations      ::Vector{Calculation} = Calculation[],\n      dir               ::String = pwd(),\n      header            ::Vector{String} = getdefault_jobheader(),\n      metadata          ::Dict = Dict(),\n      version           ::Int = last_job_version(dir),\n      copy_temp_folders ::Bool = false, \n      server            ::String = getdefault_server(),\n      environment::String =\"\")\n\nA Job embodies a set of Calculations to be ran in directory dir, with the Structure as the subject.\n\nKeywords/further attributes\n\ncalculations: calculations to calculations that will be run sequentially.\ndir: the directory where the calculations will be run.\nheader: lines that will be pasted at the head of the job script, e.g. exports export OMP_NUM_THREADS=1, slurm settings#SBATCH, etc.\nmetadata: various additional information, will be saved in .metadata.jld2 in the dir.\nversion: the current version of the job.\ncopy_temp_folders: whether or not the temporary directory associated with intermediate calculation results should be copied when storing a job version. CAUTION These can be quite large.\nserver: Server where to run the Job.\nenvironment: Environment to be used for running the Job.\n\nJob(job_name::String, structure::Structure, calculations::Vector{<:Calculation}, common_flags::Pair{Symbol, <:Any}...; kwargs...)\n\nCreates a new job. The common flags will be attempted to be set in each of the calculations. The kwargs... are passed to the Job constructor. \n\nJob(job_dir::String, job_script=\"job.sh\"; version=nothing, kwargs...)\n\nLoads the job in the dir. If job_dir is not a valid job path, the previously saved jobs will be scanned for a job with a dir that partly includes job_dir. If version is specified the corresponding job version will be returned if it exists.  The kwargs... will be passed to the Job constructor.\n\n\n\n\n\n","category":"type"},{"location":"guide/jobs/#DFControl.Database.load-Tuple{Server, Job}","page":"Jobs","title":"DFControl.Database.load","text":"load(server::Server, j::Job)\n\nTries to load the Job from server at directory j.dir. If no exact matching directory is found, a list of job directories that comprise j.dir will be returned.\n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/#Interacting-with-calculations","page":"Jobs","title":"Interacting with calculations","text":"","category":"section"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"Base.getindex(::Job, ::String)","category":"page"},{"location":"guide/jobs/#Base.getindex-Tuple{Job, String}","page":"Jobs","title":"Base.getindex","text":"getindex(job::Job, name::String)\n\nReturns the Calculation with the specified name.\n\ngetindex(job::Job, i::Integer)\n\nReturns the i'th Calculation in the job.\n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"using DFControl\njob = load(Job(joinpath(@__DIR__, \"..\", \"assets\", \"job\")))","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"Example: ","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"job[\"scf\"]\njob[2]","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"Base.push!(::Job, ::Calculation)\nBase.append!(::Job, ::Any...)\nBase.pop!(::Job)\nBase.insert!(::Job, ::Int, ::Calculation)","category":"page"},{"location":"guide/jobs/#Base.push!-Tuple{Job, Calculation}","page":"Jobs","title":"Base.push!","text":"push!(job::Job, calculation::Calculation) = push!(job.calculations, calculation)\n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/#Base.append!-Tuple{Job, Vararg{Any}}","page":"Jobs","title":"Base.append!","text":"append!(job::Job, args...) = append!(job.calculations, args...)\n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/#Base.pop!-Tuple{Job}","page":"Jobs","title":"Base.pop!","text":"pop!(job::Job) = pop!(job.calculations)\n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/#Base.insert!-Tuple{Job, Int64, Calculation}","page":"Jobs","title":"Base.insert!","text":"insert!(job::Job, i::Int, calculation::Calculation) = insert!(job.calculations, i, calculation)\n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/#Scheduling,-submission-and-monitoring","page":"Jobs","title":"Scheduling, submission and monitoring","text":"","category":"section"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"set_flow!\nsave(::Job)\nsubmit\nisrunning\nabort","category":"page"},{"location":"guide/jobs/#DFControl.Jobs.set_flow!","page":"Jobs","title":"DFControl.Jobs.set_flow!","text":"set_flow!(job::Job, should_runs::Pair{String, Bool}...)\n\nSets whether or not calculations should be scheduled to run. The name of each calculation in the job will be checked against the string in each pair of should_runs, and the calculation.run will be set accordingly.\n\nExample:\n\nset_flow!(job, \"\" => false, \"scf\" => true)\n\nwould un-schedule all calculations in the job, and schedule the \"scf\" and \"nscf\" calculations to run.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#DFControl.Database.save-Tuple{Job}","page":"Jobs","title":"DFControl.Database.save","text":"save(job::Job)\n\nSaves the job's calculations and job.sh submission script in job.dir. Some sanity checks will be performed on the validity of flags, execs, pseudopotentials, etc. The job will also be registered for easy retrieval at a later stage.\n\nIf a previous job is present in the job directory (indicated by a valid job script), it will be copied to the .versions sub directory as the previous version of job, and the version of job will be incremented. \n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/#DFControl.Client.submit","page":"Jobs","title":"DFControl.Client.submit","text":"submit(job::Job)\n\nSaves and launches job. \n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#DFControl.Client.isrunning","page":"Jobs","title":"DFControl.Client.isrunning","text":"isrunning(job::Job)\nisrunning(s::Server, jobdir::String)\n\nReturns whether a job is running or not. If the job was submitted using slurm, a QUEUED status also counts as running.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#DFControl.Client.abort","page":"Jobs","title":"DFControl.Client.abort","text":"abort(job::Job)\nabort(server::Server, dir::String)\n\nWill try to remove the job from the scheduler's queue. If the last running calculation happened to be a Calculation{QE}, the correct abort file will be written. For other codes the process is not smooth, and restarting is not guaranteed.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#Directories","page":"Jobs","title":"Directories","text":"","category":"section"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"joinpath(::Job, ::Any...)\nabspath(::Job)\ncleanup(::Job)","category":"page"},{"location":"guide/jobs/#Base.Filesystem.joinpath-Tuple{Job, Vararg{Any}}","page":"Jobs","title":"Base.Filesystem.joinpath","text":"joinpath(job::Job, args...)\n\nIf the job is local this is joinpath(job.dir, args...), otherwise it will resolve the path using the Server rootdir.\n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/#Base.Filesystem.abspath-Tuple{Job}","page":"Jobs","title":"Base.Filesystem.abspath","text":"abspath(job::Job, args...)\n\nIf the job is local this is abspath(job.dir), otherwise it will resolve the abspath using the Server rootdir.\n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/#DFControl.Client.cleanup-Tuple{Job}","page":"Jobs","title":"DFControl.Client.cleanup","text":"cleanup(job::Job)\n\nClean temporary files from the Job.\n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/#Registry","page":"Jobs","title":"Registry","text":"","category":"section"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"All Jobs are stored in an internal registry the first time save(job) is called.  This means that finding all previously worked on Jobs is as straightforward as calling load(server, Job(fuzzy)) where fuzzy is a part of the previously saved Job dir.  This will then return a list of Jobs with similar directories. ","category":"page"},{"location":"guide/jobs/#Versioning","page":"Jobs","title":"Versioning","text":"","category":"section"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"As previously mentioned, a rudimentary implementation of a Job versioning system is implemented.  Upon calling save on a Job, if there is already a valid job script present in job.dir,  it is assumed that this was a previous version of the job and the script together with all other files in job.local_dir will be copied to a subdirectory of the .versions directory bearing the name of the  respective previous job version. After this, job.version will be incremented by 1 signalling the  new version of the current Job. ","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"The virtue of this system is that it is possible to roll back to a previous version after possibly making breaking changes, or to pull out previous results after further experimentation was performed.","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"note: Note\nIf job.copy_temp_folders=true all possible intermediate files inside the temporary calculation directory  (i.e. \"job_dir/outputs\") will be copied every time the job is saved. These can be quite large and  can quickly create very large job directories. Handle with care!","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"versions\nlast_version\nswitch_version!\nrm_version!","category":"page"},{"location":"guide/jobs/#DFControl.Client.versions","page":"Jobs","title":"DFControl.Client.versions","text":"versions(job::Job)\nversions(server::Server, jobdir::String)\n\nReturs the valid versions of job.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#DFControl.Client.last_version","page":"Jobs","title":"DFControl.Client.last_version","text":"last_version(job::Job)\nlast_version(s::Server, jobdir::String)\n\nReturns the last version number of job.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#DFControl.Client.switch_version!","page":"Jobs","title":"DFControl.Client.switch_version!","text":"switch_version!(job::Job, version::Int)\n\nChanges the version of job.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#DFControl.Client.rm_version!","page":"Jobs","title":"DFControl.Client.rm_version!","text":"rm_version!(job::Job, version::Int)\n\nRemoves the version of the job.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#Archiving","page":"Jobs","title":"Archiving","text":"","category":"section"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"After a Job is completed, or an interesting result is achieved, it makes sense to store it for future reference.  This can be achieved through the archive function. This will take the current job, and copy it to a subdirectory (specified by the second argument to archive) of the jobs/archived directory inside the DFControl config directory. The third argument is a description of this job's result.","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"note: Note\nIn order to not cause huge file transfers, all the temporary directories will first be removed before archiving.","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"Example:","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"archive(job, \"test_archived_job\", \"This is a test archived job\")","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"To query previously archived jobs one can use load(Server(\"localhost\"), Job(\"archived\")).","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"archive","category":"page"},{"location":"guide/jobs/#DFControl.Client.archive","page":"Jobs","title":"DFControl.Client.archive","text":"archive(job::Job, archive_directory::AbstractString, description::String=\"\"; present = nothing, version=job.version)\n\nArchives job by copying it's contents to archive_directory alongside a results.jld2 file with all the parseable results as a Dict. description will be saved in a description.txt file in the archive_directory. \n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#Output","page":"Jobs","title":"Output","text":"","category":"section"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"outputdata\nreadfermi\nreadbands\nbandgap","category":"page"},{"location":"guide/jobs/#DFControl.Client.outputdata","page":"Jobs","title":"DFControl.Client.outputdata","text":"outputdata(job::Job; server = job.server, calcs::Vector{String}=String[])\n\nFinds the output files for each of the calculations of a Job, and groups all the parsed data into a dictionary.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#DFControl.Client.readfermi","page":"Jobs","title":"DFControl.Client.readfermi","text":"readfermi(job::Job, outdat=outputdata(job))\n\nTries to read the fermi level from a valid Calculation inside job. \n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#DFControl.Client.readbands","page":"Jobs","title":"DFControl.Client.readbands","text":"readbands(job::Job, outdat=outputdata(job))\n\nTries to read the bands from a bands calculation that is present in job.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#DFControl.bandgap","page":"Jobs","title":"DFControl.bandgap","text":"bandgap(job::Job, fermi=nothing)\n\nCalculates the bandgap (possibly indirect) around the fermi level. Uses the first found bands calculation, if there is none it uses the first found nscf calculation.\n\n\n\n\n\nbandgap(bands::AbstractVector{Band}, fermi=0.0)\n\nCalculates the bandgap (possibly indirect) around the fermi level.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#environments_header","page":"Jobs","title":"Environments","text":"","category":"section"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"Environments specify the skeleton of the job script, i.e. which environment variables need to be set, which scheduler flags, etc.","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"Environment","category":"page"},{"location":"guide/jobs/#DFControl.Jobs.Environment","page":"Jobs","title":"DFControl.Jobs.Environment","text":"Environment(MPI_command::String, scheduler_flags::Vector{String}, exports::Vector{String})\n\nEnvironment to run a Job in. When running on a server with a scheduler scheduler_flags holds what these should be. e.g. #SBATCH -N 2. MPI_command and MPI_processes will be used to prefix executables that should be ran in parallel, e.g. if MPI_command = \"mpirun -np 4 --bind-to core\" a parallel executable will be translated into a script line as mpirun -np 4 --bind-to core exec. \n\n\n\n\n\n","category":"type"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"EditURL = \"https://github.com/louisponet/DFControl.jl/blob/master/docs/src/guide/basic_tutorial.jl\"","category":"page"},{"location":"guide/basic_tutorial/#Basic-Tutorial","page":"Basic Tutorial","title":"Basic Tutorial","text":"","category":"section"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"note: Note\nMake sure to first go through the Configuration steps.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Since DFControl is aimed at improving the day to day quality of life of a material's scientist/anyone running DFT codes, we will look at a simple demonstration of how by creating and submitting some Quantum-Espresso calculations on Si starting from a cif file specifying the structure.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"using DFControl\nusing UUIDs#hide\ns = Server(name=gethostname(), port=8080, domain = \"localhost\", scheduler = Servers.Bash(), uuid = string(uuid4()), julia_exec=Sys.BINDIR * \"/julia\")#hide\nif !exists(s)#hide\n    save(s)#hide\n    Servers.initialize_config_dir(s)#hide\nelse#hide\n    s = Servers.local_server()#hide\nend#hide\nif !isalive(s)#hide\n    @async DFC.Resource.run()#hide\nend#hide","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"First we download the cif file, extract the Structure and assign the right pseudos to it. In this case Si (F d -3 m :1) from http://www.crystallography.net/cod/9011998.cif","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"using Downloads\ncif_file = Downloads.download(\"http://www.crystallography.net/cod/9011998.cif\", \"Si.cif\")\n\nstructure = Structure(cif_file)\nif false#hide\nset_pseudos!(structure, \"pbesol\")\nend#hide","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"This assumes that the \"pbesol\" pseudopotential set was installed during the configuration step.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Next we specify the executables with which to run the QE calculations. We assume here that mpirun is installed and in the user's PATH, and that QE is installed, and to be found in the /opt/qe/bin, change this according to your own setup. The first argument to the constructor can be used as a label to later retrieve the executable after it was saved.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"pw_exec = Exec(\"pw\", \"pw.x\", \"/opt/qe/bin/\", :nk => 4)","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Additional executable flags can be passed as varargs to the constructor of Exec, e.g. Exec(\"pw.x\", \"/opt/qe/bin/\", :nk => 4, :ndiag => 2).","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Then we create the first calculation for our job, we name it scf, which will be used to reference it later. We also pass the executables to be used and additional flags to be set to the constructor. Afterwards we set the kpoints to be used in the scf calculation.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"scf_calculation = Calculation(\"scf\", :calculation => \"scf\"; exec = pw_exec)\nset_kpoints!(scf_calculation, (6, 6, 6, 1, 1, 1))","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"The code recognizes internally that this 6-Tuple corresponds to a K_POINTS (automatic) block in QE. Alternatively (leading to an identical final result):","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"scf_calculation = Calculation(\"scf\", :calculation => \"scf\"; exec = pw_exec,\n                                  data = [InputData(:k_points, :automatic,\n                                                    (6, 6, 6, 1, 1, 1))])","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"We can now define our job:  job = Job(\"Si\", structure, [scfcalculation], :ecutwfc => 20, :convthr => 1e-6; dir=\"job\") Additional calculations would be be added to the list [scf_calculation]. The flag => value pairs will set the specified flags to that value for all calculations in the job that allow recognize that flag, so it's ideal for things like cutoffs and smearing etc.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"if false#hide\njob = Job(\"Si\", structure, [scf_calculation], :ecutwfc => 40.0, :occupations => \"smearing\", :degauss=>0.01, :conv_thr => 1e-6, :nbnd => 18;\n            dir = dir, server=gethostname(), environment=\"default\")\nend#hide","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"We are now ready to submit the job, which will run in the current working directory","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"if false #hide\nsubmit(job)\nelse #hide\n    global job = load(Job(joinpath(splitdir(pathof(DFControl))[1], \"..\", \"docs\",\"src\",\"assets\", \"job\")))#hide\n    pop!(job) #hide\nend #hide","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"This will generate and save all calculation files, and the corresponding job script (job.sh), to the server specified in job.server, and then the job will be submitted on the server.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"After the job finishes the outputs can be parsed through","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"outputdata(job)","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"this returns a dictionary with the input names as keys and a Dict with parsed outputs as values. i.e.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"outputdata(job)[\"scf\"]","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"takes the outputdata of the input that we previously named \"scf\" when creating it.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Now that the scf calculation finished succesfully, the next step is usually to have a look at the bandstructure. For this we generate a bands calculation, using the scf calculation as a template and a generated high symmetry k-point path with 20 kpoints per segment.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"bands_calc = Calculations.gencalc_bands(job[\"scf\"], Structures.high_symmetry_kpath(job.structure, 20))","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Observe the :calculation => \"bands\", and automatic setting of the :verbosity => \"high\" flags. We now push! this calculation to the job queue.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"push!(job, bands_calc)","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"However, since we know the scf succeeded there is no need to rerun it. To un-schedule it we do","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"job[\"scf\"].run = false","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Printing the job will now highlight the scheduled calculations differently from the non-scheduled ones","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"job","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Seeing that all is right we submit the job again","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"job.dir = \"job\"; #hide\nif false #hide\nsubmit(job)\nelse #hide\n    global job = load(Job(joinpath(splitdir(pathof(DFControl))[1], \"..\", \"docs\",\"src\",\"assets\", \"job\")));#hide\nend #hide","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"We can access the bands through","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"bands = readbands(job);\nnothing #hide","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"or","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"bands = outputdata(job)[\"bands\"][:bands];\nnothing #hide","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"They can be plotted too","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"fermi = readfermi(job) # = outputdata(job)[\"scf\"][:fermi]\nusing Plots\nplot(bands; fermi = fermi)","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Since more info (such as the structure) is available in the job, plotting the job leads to a richer plot","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"plot(job, -10, 1)","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"As can be seen in the Advanced Usage, additional information generated by additional calculations will be picked up by DFControl in order to create richer plots.","category":"page"},{"location":"guide/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"guide/installation/","page":"Installation","title":"Installation","text":"In case you don't have a working Julia installation yet, first download the Julia binaries and follow the Julia installation instructions.","category":"page"},{"location":"guide/installation/","page":"Installation","title":"Installation","text":"note: Note\nDFControl requires Julia 1.6 or newer, the server side functionality will not work with older versions.","category":"page"},{"location":"guide/installation/","page":"Installation","title":"Installation","text":"Afterwards you can install DFControl like any other package in Julia. For example run in your Julia REPL terminal:","category":"page"},{"location":"guide/installation/","page":"Installation","title":"Installation","text":"import Pkg\nPkg.add(\"DFControl\")","category":"page"},{"location":"guide/installation/","page":"Installation","title":"Installation","text":"which will install the latest DFControl release. Alternatively (if you like to be fully up to date) install the master branch:","category":"page"},{"location":"guide/installation/","page":"Installation","title":"Installation","text":"import Pkg\nPkg.add(name=\"DFControl\", rev=\"master\")","category":"page"},{"location":"guide/installation/","page":"Installation","title":"Installation","text":"DFControl is continuously tested on Debian, Ubuntu, mac OS and Windows and should work on these operating systems out of the box.","category":"page"},{"location":"guide/installation/","page":"Installation","title":"Installation","text":"After these steps it is highly recommended to go through some additional Configuration.","category":"page"},{"location":"guide/configuration/#Configuration","page":"Configuration","title":"Configuration","text":"","category":"section"},{"location":"guide/configuration/#[Servers](@ref-servers_header)","page":"Configuration","title":"Servers","text":"","category":"section"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"Since DFControl utilizes a client-server rest-api model, each server will have its own local deamon running, which stores certain server-side items such as pseudopotentials, Environments and Execs.","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"First start by setting up your local server:","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"Servers.configure_local()","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"To set up another Server, in this case with name = \"daint\" an interactive menu can be called like:","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"Server(\"daint\")","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"This will set up all the required information and store it for later use. To start a Server simply call start(server), which will launch the daemon externally.","category":"page"},{"location":"guide/configuration/#Pseudopotentials","page":"Configuration","title":"Pseudopotentials","text":"","category":"section"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"Pseudopotentials are grouped in sets, which are stored for later ease of use. They can be set up using the configure_pseudoset function.","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"configure_pseudoset(local_server(), \"set_name\", \"/dir/to/pseudos\")","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"This will go through the specified directories and find files that follow the naming convention element.x_y_z.xyz e.g. Si.pbesol-n-kjpaw_psl.0.1.UPF or si.pbesol-n-kjpaw_psl.0.1.UPF.  If multiple are found, all will be stored and the required one can be later specified.","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"The pseudos will remain on the server where they are stored, and can be listed using list_pseudosets. See Pseudo Potentials for further usage details.","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"configure_pseudoset\nlist_pseudosets\nrm_pseudoset!","category":"page"},{"location":"guide/configuration/#DFControl.Client.configure_pseudoset","page":"Configuration","title":"DFControl.Client.configure_pseudoset","text":"configure_pseudoset(server::Server, set_name::String, dir::String)\n\nReads the specified dir and sets up the pseudos for set.\n\n\n\n\n\n","category":"function"},{"location":"guide/configuration/#DFControl.Client.list_pseudosets","page":"Configuration","title":"DFControl.Client.list_pseudosets","text":"list_pseudosets(server::Server)\n\nLists the pseudosets that have previously been set up.\n\n\n\n\n\n","category":"function"},{"location":"guide/configuration/#DFControl.Client.rm_pseudoset!","page":"Configuration","title":"DFControl.Client.rm_pseudoset!","text":"rm_pseudoset!(server::Server, set_name::String)\n\nRemoves the pseudo set from the server.\n\n\n\n\n\n","category":"function"},{"location":"guide/configuration/#[Environments](@ref-environments_header)","page":"Configuration","title":"Environments","text":"","category":"section"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"Environments specify the skeleton of the job script, i.e. which environment variables need to be set, which scheduler flags, etc. Here we will set up an environment and save it on the local Server. Change the information according to your own setup.","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"e = Environment(name=\"default\", MPI_command=\"mpirun -np 4\", scheduler_flags=[\"-N 1\", \"--partition=parallel\"], exports=[\"OMP_NUM_THREADS=1\"])\nsave(local_server(), e)","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"While not recommended because it doesn't always work, one can try to extract an environment from a preexisting jobscript using","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"DFC.Client.environment_from_jobscript","category":"page"},{"location":"guide/configuration/#DFControl.Client.environment_from_jobscript","page":"Configuration","title":"DFControl.Client.environment_from_jobscript","text":"environment_from_jobscript([server::Server, name::String,] scriptpath::String)\n\nTries to extract an Environment from a jobscript.\n\n\n\n\n\n","category":"function"},{"location":"guide/configuration/#[Execs](@ref-execs_header)","page":"Configuration","title":"Execs","text":"","category":"section"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"An Exec embodies an executable as the name suggests. They hold both the executable, directory and modules required to run the executable. Similar to Environments, they are stored on the server for later use. When storing it is verified that they are able to run.","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"e = Exec(name=\"pw\", exec=\"pw.x\", dir=\"/home/user/Softare/qe/bin\", modules = [\"intel\", \"intel-mpi\", \"intel-mkl\"])\nsave(local_server(), e)","category":"page"},{"location":"guide/configuration/#Loading/Saving","page":"Configuration","title":"Loading/Saving","text":"","category":"section"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"As shown above there are three main methods related to storing and retrieving data i.e.:","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"Database.load\nDatabase.save\nrm(::Database.Storable)","category":"page"},{"location":"guide/configuration/#DFControl.Database.load","page":"Configuration","title":"DFControl.Database.load","text":"load(server::Server, j::Job)\n\nTries to load the Job from server at directory j.dir. If no exact matching directory is found, a list of job directories that comprise j.dir will be returned.\n\n\n\n\n\nload([server::Server], e::Environment)\nload([server::Server], e::Exec)\nload([server::Server], s::Server)\n\nLoads a previously stored item from the server. If server is not specified the local item is loaded.\n\n\n\n\n\n","category":"function"},{"location":"guide/configuration/#DFControl.Database.save","page":"Configuration","title":"DFControl.Database.save","text":"save(job::Job)\n\nSaves the job's calculations and job.sh submission script in job.dir. Some sanity checks will be performed on the validity of flags, execs, pseudopotentials, etc. The job will also be registered for easy retrieval at a later stage.\n\nIf a previous job is present in the job directory (indicated by a valid job script), it will be copied to the .versions sub directory as the previous version of job, and the version of job will be incremented. \n\n\n\n\n\nsave([server::Server], e::Environment)\nsave([server::Server], e::Exec)\nsave([server::Server], s::Server)\n\nSaves an item to the database of server. If server is not specified the item will be stored in the local database.\n\n\n\n\n\n","category":"function"},{"location":"guide/configuration/#Base.Filesystem.rm-Tuple{Storable}","page":"Configuration","title":"Base.Filesystem.rm","text":"Base.rm([server::Server], e::Environment)\nBase.rm([server::Server], e::Exec)\nBase.rm([server::Server], s::Server)\n\nRemoves an item from the database of server. If server is not specified the item will removed from the local database.\n\n\n\n\n\n","category":"method"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"After completing this configuration, it is suggested to look at the (Basic Usage)[@ref] for an introduction to the basic usage of DFControl.","category":"page"},{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"This page provides a plain list of all inline documention associated with functions, structs  and macros in DFControl. Note that this list is neither structured, complete nor particularly clean, so it only provides rough orientation at the moment. The best reference is the code itself.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"EditURL = \"https://github.com/louisponet/DFControl.jl/blob/master/docs/src/guide/advanced_tutorial.jl\"","category":"page"},{"location":"guide/advanced_tutorial/#Advanced-Usage","page":"Advanced Tutorial","title":"Advanced Usage","text":"","category":"section"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"In this tutorial we will continue from the job created in the Basic Tutorial, and demonstrate some more advanced functionality that DFControl offers.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"To load a previously saved job we here provide a valid job directory with a job.sh script in it.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"using DFControl\n\ntjob = load(Job(joinpath(splitdir(pathof(DFControl))[1], \"..\", \"docs\",\"src\",\"assets\", \"job\")))#hide\ntjob2 = load(Job(joinpath(splitdir(pathof(DFControl))[1], \"..\", \"docs\",\"src\",\"assets\", \"Job2\")))#hide\nif false#hide\njob = load(Servers.local_server(), Job(\"job\"))\nelse#hide\n    global job = deepcopy(tjob)#hide\n    job.dir= \"job\" #hide\n    job#hide\nend#hide","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Since the job created in the Basic Tutorial was saved in the \"job\" directory this will work, see the section on Jobs for further details and options on how to load previously saved jobs.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"The next thing we may want to do is to change the directory where the job is running.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"if false#hide\njob.dir = \"Job2\"\nelse#hide\n    global job = deepcopy(tjob2)#hide\n    pop!(job)#hide\n    pop!(job)#hide\n    job#hide\nend#hide","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"With the copy=true flag we let DFControl know that not only to create and set the new directory, but also to copy the previous results and temporary files to the new directory so we don't have to rerun the scf calculation.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Next we would like to plot the projected density of states. For that we create both an nscf calculation to get a uniform k-grid, and projwfc calculation.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"push!(job, Calculations.gencalc_nscf(job[\"scf\"], (6, 6, 6)))","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"The second argument of gencalc_nscf is the kgrid. When passing a 3-Tuple, the code will assume that an explicit k-grid is requested, which can be verified by","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"data(job[\"nscf\"], :k_points)","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Next we generate a projwfc calculation using the fermi level as a guide for the energy window. The arguments are structured as (template, Emin, Emax, deltaE) respectively.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"fermi = readfermi(job)\npush!(job, Calculations.gencalc_projwfc(job[\"nscf\"], fermi - 10, fermi + 1, 0.1))","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Next we disable the bands calculation and run the new ones.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"job[\"bands\"].run = false\nif false#hide\n    submit(job)\nelse#hide\n    global job = deepcopy(tjob2)#hide\nend#hide","category":"page"},{"location":"guide/advanced_tutorial/#results_plotting","page":"Advanced Tutorial","title":"Plot Results","text":"","category":"section"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"using Plots\nplot(job, -10, 1)","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"As we can see, again DFControl identifies the additional information that is now present in the job, and uses it to display in the plot.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"In the demonstrated case we see that everything went according to plan, however, often things need to be changed in a trial and error way until the desired results are found.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"On common occurence is that calculation flags have to be set, or changed. This can be done in two ways","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"job[:ecutwfc] = 40.0","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"will go through all the calculations of the job and set the flag if it is allowed, i.e. the flag will not be set in the projwfc calculation since it makes no sense.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"job[\"bands\"][:nbnd] = 30","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"This will set a flag for one specific calculation, again checking whether the flag is valid, and the type will be converted to the correct one.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"In order to quickly specify what calculations to schedule and which not, one can use","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Jobs.set_flow!(job, \"\" => false, \"scf\" => true)","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"As we can see, only the scf and nscf calculations are scheduled to run now, this is because for each of the pairs in the arguments of set_flow!, every calculation inside the job for which the string occurs in the name will be set to run or not depending on the Bool.","category":"page"},{"location":"guide/calculations/#Calculations","page":"Calculations","title":"Calculations","text":"","category":"section"},{"location":"guide/calculations/#Contents","page":"Calculations","title":"Contents","text":"","category":"section"},{"location":"guide/calculations/","page":"Calculations","title":"Calculations","text":"Pages=[\"calculations.md\"]","category":"page"},{"location":"guide/calculations/#Index","page":"Calculations","title":"Index","text":"","category":"section"},{"location":"guide/calculations/","page":"Calculations","title":"Calculations","text":"Pages=[\"calculations.md\"]","category":"page"},{"location":"guide/calculations/","page":"Calculations","title":"Calculations","text":"Calculation\nInputData","category":"page"},{"location":"guide/calculations/#DFControl.Calculations.Calculation","page":"Calculations","title":"DFControl.Calculations.Calculation","text":"Calculation{P<:Package}(name    ::String;\n                        flags   ::AbstractDict = Dict{Symbol, Any}(),\n                        data    ::Vector{InputData} = InputData[],\n                        exec    ::Exec,\n                        run     ::Bool = true,\n                        infile  ::String = P == Wannier90 ? name * \".win\" : name * \".in\",\n                        outfile ::String = name * \".out\")\n\nThe representation of a DFT calculation of package P, holding the flags that will be written to the infile, the executable exec and the output written by the calculation to the outfile. It essentially represents a line in a job script similar to exec < infile.in > outfile.out.  outdata stores the parsed calculation output after it was read at least once. The run field indicates whether the calculation should be actually performed, e.g. if run=false the corresponding line will be commented out in the job script.\n\nCalculation{P<:Package}(name::AbstractString, flags::Pair{Symbol, Any}...; kwargs...)\n\nCreate a Calculation from name and flags, other kwargs... will be passed to the constructor.\n\nCalculation(template::Calculation, name::AbstractString, flags::Pair{Symbol, Any}...; excs=deepcopy(template.exec), run=true, data=nothing)\n\nCreates a new Calculation from the template, setting the flags of the newly created one to the specified ones.\n\n\n\n\n\n","category":"type"},{"location":"guide/calculations/#DFControl.Calculations.InputData","page":"Calculations","title":"DFControl.Calculations.InputData","text":"InputData(name::Symbol, option::Symbol, data::Any)\n\nRepresents a more structured block of input data. e.g. InputData(:k_points, :automatic, (6,6,6,1,1,1)) would be translated for a QE calculation into\n\nK_POINTS(automatic)\n6 6 6 1 1 1\n\n\n\n\n\n","category":"type"},{"location":"guide/calculations/#Basic-interaction","page":"Calculations","title":"Basic interaction","text":"","category":"section"},{"location":"guide/calculations/","page":"Calculations","title":"Calculations","text":"Calculations.set_name!\nCalculations.data\nCalculations.set_kpoints!","category":"page"},{"location":"guide/calculations/#DFControl.Calculations.set_name!","page":"Calculations","title":"DFControl.Calculations.set_name!","text":"set_name!(c::Calculation, name::AbstractString)\n\nSets calculation.name, and calculation.infile and calculation.outfile to conform with the new name.\n\n\n\n\n\n","category":"function"},{"location":"guide/calculations/#DFControl.Calculations.data","page":"Calculations","title":"DFControl.Calculations.data","text":"data(calculation::Calculation, n::Symbol)\n\nThe former returns calculation.data, the later – the InputData with name n.\n\n\n\n\n\n","category":"function"},{"location":"guide/calculations/#DFControl.Calculations.set_kpoints!","page":"Calculations","title":"DFControl.Calculations.set_kpoints!","text":"set_kpoints!(calculation::Calculation{QE}, k_grid::NTuple{3, Int}; print=true)\nset_kpoints!(calculation::Calculation{QE}, k_grid::NTuple{6, Int}; print=true)\nset_kpoints!(calculation::Calculation{QE}, k_grid::Vector{<:NTuple{4}}; print=true, k_option=:crystal_b)\n\nConvenience function to set the :k_points data block of calculation. The three different methods are targeted at nscf, scf or vcrelax, and bands calculations, respectively. For the nscf version an explicit list of k_points will be generated.\n\nset_kpoints!(calculation::Calculation{Wannier90}, k_grid::NTuple{3, Int})\n\nSimilar to the nscf targeted function in the sense that it will generate an explicit list of k_points, adhering to the same rules as for the nscf. The mp_grid flag will also automatically be set.\n\n\n\n\n\n","category":"function"},{"location":"guide/calculations/#Flags","page":"Calculations","title":"Flags","text":"","category":"section"},{"location":"guide/calculations/","page":"Calculations","title":"Calculations","text":"A big part of working with DFT calculations is specifying the various calculation flags. Remembering all the names of the flags, where they belong, and what types they are expected to be, is quite complicated and can lead to easily made mistakes like typos. DFControl tries to catch these as it knows which flags are allowed for which calculations. It will report when a flag can not be found for a given Calculation, and it will also try to convert a flag value to the expected type.","category":"page"},{"location":"guide/calculations/","page":"Calculations","title":"Calculations","text":"A Calculation behaves a lot as a normal Dict to interact with the stored flags. This means that the usual Dict operations such as haskey, get, and pop! work on a Calculation.","category":"page"},{"location":"guide/calculations/","page":"Calculations","title":"Calculations","text":"Base.getindex(::Calculation, ::Symbol)\nBase.setindex!(::Calculation, ::Symbol, ::Any)\nCalculations.set_flags!","category":"page"},{"location":"guide/calculations/#Base.getindex-Tuple{Calculation, Symbol}","page":"Calculations","title":"Base.getindex","text":"getindex(c::Calculation, n::Symbol)\n\nReturns the flag with given symbol.\n\ngetindex(job::Job, flag::Symbol)\n\nSearches through the job's calculations for the requested flag. A Dict will be returned with calculation names as the keys and the flags as values.\n\n\n\n\n\n","category":"method"},{"location":"guide/calculations/#Base.setindex!-Tuple{Calculation, Symbol, Any}","page":"Calculations","title":"Base.setindex!","text":"setindex!(c::Calculation, value, flag::Symbol)\n\nSets flags.\n\nsetindex!(job::Job, value, flag::Symbol)\n\nSet flag in all the appropriate calculations to the value.\n\n\n\n\n\n","category":"method"},{"location":"guide/calculations/#DFControl.Calculations.set_flags!","page":"Calculations","title":"DFControl.Calculations.set_flags!","text":"set_flags!(c::Calculation, flags::Pair{Symbol, Any}...; print=true, force=false)\n\nSets multiple flags in one go. Flag validity and type are verified.\n\nset_flags!(job::Job, calculations::Vector{<:Calculation}, flags::Pair{Symbol,<:Any}...; print=true)\nset_flags!(job::Job, flags::Pair{Symbol,<:Any}...; print=true)\n\nSets the flags in the names to the flags specified. This only happens if the specified flags are valid for the names.\n\n\n\n\n\n","category":"function"},{"location":"guide/calculations/#execs_header","page":"Calculations","title":"Execs","text":"","category":"section"},{"location":"guide/calculations/","page":"Calculations","title":"Calculations","text":"Exec","category":"page"},{"location":"guide/calculations/#DFControl.Calculations.Exec","page":"Calculations","title":"DFControl.Calculations.Exec","text":"Exec(;exec::String = \"\", dir::String = \"\", flags::Vector{ExecFlag} = ExecFlag[])\n\nRepresentation of an executable that will run the Calculation. Basically dir/exec --<flags> inside a job script.\n\nExec(exec::String, dir::String, flags::Pair{Symbol}...)\n\nWill first transform flags into a Vector{ExecFlag}, and construct the Exec. \n\n\n\n\n\n","category":"type"},{"location":"guide/calculations/#calculation_generation","page":"Calculations","title":"Generating new calculations","text":"","category":"section"},{"location":"guide/calculations/","page":"Calculations","title":"Calculations","text":"Calculations.gencalc_vcrelax(::Calculation{QE}, ::NTuple{6, Int}, ::Any...)\nCalculations.gencalc_scf(::Calculation{QE}, ::NTuple{6, Int}, ::Any...)\nCalculations.gencalc_bands(::Calculation{QE}, ::Vector{<:NTuple{4}}, ::Any...)\nCalculations.gencalc_nscf(::Calculation{QE}, kpoints::NTuple{3, Int}, ::Any...)\nCalculations.gencalc_projwfc(::Calculation{QE}, ::Real, ::Real, ::Real)\nCalculations.gencalc_wan","category":"page"},{"location":"guide/calculations/#DFControl.Calculations.gencalc_vcrelax-Tuple{Calculation{QE}, NTuple{6, Int64}, Vararg{Any}}","page":"Calculations","title":"DFControl.Calculations.gencalc_vcrelax","text":"gencalc_vcrelax(template::Calculation{QE}, kpoints::NTuple{6, Int}, newflags...; name=\"scf\")\n\nUses the information from the template and supplied kpoints to generate a vcrelax calculation. Extra flags can be supplied which will be set for the generated calculation.\n\n\n\n\n\n","category":"method"},{"location":"guide/calculations/#DFControl.Calculations.gencalc_scf-Tuple{Calculation{QE}, NTuple{6, Int64}, Vararg{Any}}","page":"Calculations","title":"DFControl.Calculations.gencalc_scf","text":"gencalc_scf(template::Calculation{QE}, kpoints::NTuple{6, Int}, newflags...; name=\"scf\")\n\nUses the information from the template and supplied kpoints to generate an scf calculation. Extra flags can be supplied which will be set for the generated calculation.\n\n\n\n\n\n","category":"method"},{"location":"guide/calculations/#DFControl.Calculations.gencalc_bands-Tuple{Calculation{QE}, Vector{<:NTuple{4, T} where T}, Vararg{Any}}","page":"Calculations","title":"DFControl.Calculations.gencalc_bands","text":"gencalc_bands(template::Calculation{QE}, kpoints::Vector{NTuple{4}}, newflags...; name=\"bands\")\n\nUses the information from the template and supplied kpoints to generate a bands calculation. Extra flags can be supplied which will be set for the generated calculation.\n\n\n\n\n\n","category":"method"},{"location":"guide/calculations/#DFControl.Calculations.gencalc_nscf-Tuple{Calculation{QE}, Tuple{Int64, Int64, Int64}, Vararg{Any}}","page":"Calculations","title":"DFControl.Calculations.gencalc_nscf","text":"gencalc_nscf(template::Calculation{QE}, kpoints::NTuple{3, Int}, newflags...; name=\"nscf\")\n\nUses the information from the template and supplied kpoints to generate an nscf calculation. Extra flags can be supplied which will be set for the generated calculation.\n\n\n\n\n\n","category":"method"},{"location":"guide/calculations/#DFControl.Calculations.gencalc_projwfc-Tuple{Calculation{QE}, Real, Real, Real}","page":"Calculations","title":"DFControl.Calculations.gencalc_projwfc","text":"gencalc_projwfc(template::Calculation{QE}, Emin, Emax, DeltaE, newflags...; name=\"projwfc\")\n\nUses the information from the template and supplied kpoints to generate a projwfc.x calculation. Extra flags can be supplied which will be set for the generated calculation.\n\n\n\n\n\n","category":"method"},{"location":"guide/calculations/#DFControl.Calculations.gencalc_wan","page":"Calculations","title":"DFControl.Calculations.gencalc_wan","text":"gencalc_wan(job::Job, min_window_determinator::Real, extra_wan_flags...; kwargs...)\n\nAutomates the generation of wannier calculations based on the job. When a projwfc calculation is present in the job, min_window_determinator will be used to determine the threshold value for including a band in the window based on the projections, otherwise it will be used as the Emin value from which to start counting the number of bands needed for all projections. extra_wan_flags can be any extra flags for the Wannier90 calculation such as write_hr etc.\n\n\n\n\n\ngencalc_wan(nscf::Calculation{QE}, structure::Structure, Emin, wanflags...;\n            Epad     = 5.0,\n            wanexec  = Exec(exec=\"wannier90.x\", dir=\"\"))\n\nGenerates a Wannier90 calculation to follow on the supplied nscf calculation. It uses the projections defined in the structure, and starts counting the required amount of bands from Emin. The nscf needs to have a valid output since it will be used in conjunction with Emin to find the required amount of bands and energy window for the Wannier90 calculation.\n\n\n\n\n\n","category":"function"},{"location":"#DFControl","page":"Home","title":"DFControl","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The goal of DFControl is to alleviate some of the tedious day to day busy-work that material's scientists using DFT  codes encounter. It aids in the creation, execution, monitoring, management, and post-processing of DFT jobs.  The core framework is code-agnostic, however, most of the convenience features are so far only implemented for Quantum-Espresso and Wannier90. ABINIT and ELK support is highly experimental and incomplete.","category":"page"},{"location":"#Philosophy","page":"Home","title":"Philosophy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DFControl is aimed to be user friendly first and foremost, with features being added as time progresses without changing this core value. On the other hand, a core requirement has always been that power users that know all the ins and outs of the codes that they run should be able to have all the control they want without incurring friction from the library. DFControl therefore should never be a barrier to DFT code functionality, just a tool to increase efficiency of its users.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In light of this DFControl is structured to mimic the often adopted strategy of a linear submission script that specifies which input files  are ran with which DFT codes producing which outputs. Everything revolves around the Job that holds a collection of Calculations which will be ran sequentially in the job's directory, on the job's crystal Structure. A Job is therefore identified with a specific directory. Using the script that is created upon saving or submitting a job, a Job can be easily reloaded at a later stage to continue the investigation where left off.","category":"page"},{"location":"#Highlighted-features","page":"Home","title":"Highlighted features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Creation and submission of a simple self-consistent-field calculation starting from a structure Cif file in less than 10 lines of code (see the Basic Tutorial])\nSeparation of Structure and Calculation so that the same Calculations can be copied and used with a different Structure in a new job \nAutomatic validation and conversion of input flags\nTracking of Jobs for ease of continuation at later times\nEase of calculation generation\nAutomatic plotting of available results using a single command\nInput flag sanity checks\nRudimentary Job versioning to never lose previous Job's results even if running in the same directory\nFully human readable and transparent Job directory structure ","category":"page"}]
}

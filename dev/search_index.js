var documenterSearchIndex = {"docs":
[{"location":"guide/jobs/#Jobs","page":"Jobs","title":"Jobs","text":"","category":"section"},{"location":"guide/jobs/#Contents","page":"Jobs","title":"Contents","text":"","category":"section"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"Pages=[\"jobs.md\"]","category":"page"},{"location":"guide/jobs/#Index","page":"Jobs","title":"Index","text":"","category":"section"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"Pages=[\"jobs.md\"]","category":"page"},{"location":"guide/jobs/#DFJob","page":"Jobs","title":"DFJob","text":"","category":"section"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"DFJob","category":"page"},{"location":"guide/jobs/#DFControl.DFJob","page":"Jobs","title":"DFControl.DFJob","text":"DFJob(name::String, structure::AbstractStructure;\n      calculations      ::Vector{DFCalculation} = DFCalculation[],\n      local_dir         ::String = pwd(),\n      header            ::Vector{String} = getdefault_jobheader(),\n      metadata          ::Dict = Dict(),\n      version           ::Int = last_job_version(local_dir),\n      copy_temp_folders ::Bool = false, \n      server            ::String = getdefault_server(),\n      server_dir        ::String = \"\")\n\nA DFJob embodies a set of DFCalculations to be ran in directory local_dir, with the Structure as the subject.\n\nKeywords/further attributes\n\ncalculations: calculations to calculations that will be run sequentially.\nlocal_dir: the directory where the calculations will be run.\nheader: lines that will be pasted at the head of the job script, e.g. exports export OMP_NUM_THREADS=1, slurm settings#SBATCH, etc.\nmetadata: various additional information, will be saved in .metadata.jld2 in the local_dir.\nversion: the current version of the job.\ncopy_temp_folders: whether or not the temporary directory associated with intermediate calculation results should be copied when storing a job version. CAUTION These can be quite large.\nThe server and server_dir keywords should be avoided for the time being, as this functionality is not well tested.\n\nDFJob(job_name::String, structure::AbstractStructure, calculations::Vector{<:DFCalculation}, common_flags::Pair{Symbol, <:Any}...; kwargs...)\n\nCreates a new job. The common flags will be attempted to be set in each of the calculations. The kwargs... are passed to the DFJob constructor. \n\nDFJob(job_dir::String, job_script=\"job.tt\"; version=nothing, kwargs...)\n\nLoads the job in the local_dir. If job_dir is not a valid job path, the previously saved jobs will be scanned for a job with a local_dir that partly includes job_dir. If version is specified the corresponding job version will be returned if it exists.  The kwargs... will be passed to the DFJob constructor.\n\n\n\n\n\n","category":"type"},{"location":"guide/jobs/#Interacting-with-calculations","page":"Jobs","title":"Interacting with calculations","text":"","category":"section"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"Base.getindex(::DFJob, ::String)","category":"page"},{"location":"guide/jobs/#Base.getindex-Tuple{DFJob, String}","page":"Jobs","title":"Base.getindex","text":"getindex(job::DFJob, name::String)\n\nReturns the DFCalculation with the specified name.\n\ngetindex(job::DFJob, i::Integer)\n\nReturns the i'th DFCalculation in the job.\n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"using DFControl\njob = DFJob(joinpath(pathof(DFControl), \"..\", \"..\", \"docs\", \"src\", \"assets\", \"job\"))","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"Example: ","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"job[\"scf\"]\njob[2]","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"Base.push!(::DFJob, ::DFCalculation)\nBase.append!(::DFJob, ::Any...)\nBase.pop!(::DFJob)\nBase.insert!(::DFJob, ::Int, ::DFCalculation)","category":"page"},{"location":"guide/jobs/#Base.push!-Tuple{DFJob, DFCalculation}","page":"Jobs","title":"Base.push!","text":"push!(job::DFJob, calculation::DFCalculation) = push!(job.calculations, calculation)\n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/#Base.append!-Tuple{DFJob, Vararg{Any, N} where N}","page":"Jobs","title":"Base.append!","text":"append!(job::DFJob, args...) = append!(job.calculations, args...)\n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/#Base.pop!-Tuple{DFJob}","page":"Jobs","title":"Base.pop!","text":"pop!(job::DFJob) = pop!(job.calculations)\n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/#Base.insert!-Tuple{DFJob, Int64, DFCalculation}","page":"Jobs","title":"Base.insert!","text":"insert!(job::DFJob, i::Int, calculation::DFCalculation) = insert!(job.calculations, i, calculation)\n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/#Scheduling,-submission-and-monitoring","page":"Jobs","title":"Scheduling, submission and monitoring","text":"","category":"section"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"set_flow!\nsave(::DFJob)\nsubmit\nisrunning\nlast_submission\nlast_running_calculation\nabort","category":"page"},{"location":"guide/jobs/#DFControl.set_flow!","page":"Jobs","title":"DFControl.set_flow!","text":"set_flow!(job::DFJob, should_runs::Pair{String, Bool}...)\n\nSets whether or not calculations should be scheduled to run. The name of each calculation in the job will be checked against the string in each pair of should_runs, and the calculation.run will be set accordingly.\n\nExample:\n\nset_flow!(job, \"\" => false, \"scf\" => true)\n\nwould un-schedule all calculations in the job, and schedule the \"scf\" and \"nscf\" calculations to run.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#DFControl.save-Tuple{DFJob}","page":"Jobs","title":"DFControl.save","text":"save(job::DFJob)\n\nSaves the job's calculations and job.tt submission script in job.local_dir. Some sanity checks will be performed on the validity of flags, execs, pseudopotentials, etc. The job will also be registered for easy retrieval at a later stage.\n\nIf a previous job is present in the job directory (indicated by a valid job script), it will be copied to the .versions sub directory as the previous version of job, and the version of job will be incremented. \n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/#DFControl.submit","page":"Jobs","title":"DFControl.submit","text":"submit(job::DFJob; kwargs...)\n\nFirst saves the job, then tries to submit the job script through sbatch job.tt or bash job.tt if the former command fails. kwargs... get passed to save(job; kwargs...).\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#DFControl.isrunning","page":"Jobs","title":"DFControl.isrunning","text":"isrunning(job::DFJob; print=true)\n\nReturns whether a job is running or not. If the job was submitted using slurm, a QUEUED status also counts as running.\n\n!!! note:     For now only slurm is supported as scheduler.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#DFControl.last_submission","page":"Jobs","title":"DFControl.last_submission","text":"last_submission(job::DFJob)\n\nIf a job was ever submitted, the last submission date is returned. Otherwise 0 date is returned.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#DFControl.last_running_calculation","page":"Jobs","title":"DFControl.last_running_calculation","text":"last_running_calculation(job::DFJob)\n\nReturns the last DFCalculation for which an output file was created.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#DFControl.abort","page":"Jobs","title":"DFControl.abort","text":"abort(job::DFJob)\n\nWill try to remove the job from the scheduler's queue. If the last running calculation happened to be a DFCalculation{QE}, the correct abort file will be written. For other codes the process is not smooth, and restarting is not guaranteed.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#Management","page":"Jobs","title":"Management","text":"","category":"section"},{"location":"guide/jobs/#Directories","page":"Jobs","title":"Directories","text":"","category":"section"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"set_localdir!(::DFJob, ::String)\nBase.cp(::DFJob, ::String)\nBase.mv(::DFJob, ::String)\nBase.filesize\nBase.joinpath(::DFJob, ::Any...)\ncleanup","category":"page"},{"location":"guide/jobs/#DFControl.set_localdir!-Tuple{DFJob, String}","page":"Jobs","title":"DFControl.set_localdir!","text":"set_localdir!(job::DFJob, dir::AbstractString; copy=false)\n\nSets job.local_dir to dir. If necessary the directory will be created. If copy is set to true, all previous calculations and output files of the current job version (i.e. those in the main job directory) will be copied to the new directory, including the outputs directory with temporary files created during jobs runs.\n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/#Base.Filesystem.cp-Tuple{DFJob, String}","page":"Jobs","title":"Base.Filesystem.cp","text":"cp(job::DFJob, dest::AbstractString; all=false, temp=false, kwargs...)\n\nCopies the contents of job.local_dir to dest. If all=true, it will also copy the .version directory with all previous versions. If temp=true it will override job.copy_temp_folders and copy also the temporary calculation directories. The kwargs... are passed to Base.cp.\n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/#Base.Filesystem.mv-Tuple{DFJob, String}","page":"Jobs","title":"Base.Filesystem.mv","text":"mv(job::DFJob, dest::AbstractString; all=false, temp=false, kwargs...)\n\nMoves the contents of job.local_dir to dest. If all=true, it will also move the .version directory with all previous versions. If temp=true it will override job.copy_temp_folders and move also the temporary calculation directories. The kwargs... are passed to Base.mv.\n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/#Base.filesize","page":"Jobs","title":"Base.filesize","text":"filesize(job::DFJob)\n\nTotal filesize on disk for a job and all its versions.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#Base.Filesystem.joinpath-Tuple{DFJob, Vararg{Any, N} where N}","page":"Jobs","title":"Base.Filesystem.joinpath","text":"joinpath(job::DFJob, args...)\n\njoinpath(job.local_dir, args...).\n\n\n\n\n\n","category":"method"},{"location":"guide/jobs/#DFControl.cleanup","page":"Jobs","title":"DFControl.cleanup","text":"cleanup(job::DFJob)\n\nCleanup job.local_dir interactively.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#Registry","page":"Jobs","title":"Registry","text":"","category":"section"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"All DFJobs are stored in an internal registry the first time save(job) is called.  This means that finding all previously worked on DFJobs is as straightforward as calling DFJob(fuzzy) where fuzzy is a part of the previously saved DFJob local_dir.  This will then show a menu in the REPL with the possible choices and one will be loaded upon choosing.","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"Loading all DFJobs that contain a given fuzzy can be done through load_jobs(fuzzy).","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"registered_jobs\nload_jobs\nrunning_jobs","category":"page"},{"location":"guide/jobs/#DFControl.registered_jobs","page":"Jobs","title":"DFControl.registered_jobs","text":"registered_jobs(fuzzy::AbstractString = \"\")\n\nLists all the known DFJobs directories that contain fuzzy. Intended to be used as:\n\njob_dirs = registered_jobs(\"NiO\")\njob = DFJob(job_dirs[1])\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#DFControl.load_jobs","page":"Jobs","title":"DFControl.load_jobs","text":"load_jobs(fuzzy::AbstractString)\n\nLoads all the known DFJobs whose local_dir contains fuzzy.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#DFControl.running_jobs","page":"Jobs","title":"DFControl.running_jobs","text":"running_jobs(fuzzy::AbstractString = \"\")\n\nLoads all DFJobs that are currently running.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#Versioning","page":"Jobs","title":"Versioning","text":"","category":"section"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"As previously mentioned, a rudimentary implementation of a DFJob versioning system is implemented.  Upon calling save on a DFJob, if there is already a valid job script present in job.local_dir,  it is assumed that this was a previous version of the job and the script together with all other files in job.local_dir will be copied to a subdirectory of the .versions directory bearing the name of the  respective previous job version. After this, job.version will be incremented by 1 signalling the  new version of the current job. ","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"The virtue of this system is that it is possible to roll back to a previous version after possibly making breaking changes, or to pull out previous results after further experimentation was performed.","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"note: Note\nIf job.copy_temp_folders=true all possible intermediate files inside the temporary calculation directory  (i.e. \"job_dir/outputs\") will be copied every time the job is saved. These can be quite large and  can quickly create very large job directories. Handle with care!","category":"page"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"versions\nlast_version\nswitch_version!\nrm_version!","category":"page"},{"location":"guide/jobs/#DFControl.versions","page":"Jobs","title":"DFControl.versions","text":"versions(job::DFJob)\n\nReturs the valid versions of job.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#DFControl.last_version","page":"Jobs","title":"DFControl.last_version","text":"last_version(job::DFJob)\n\nReturns the last version number of job.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#DFControl.switch_version!","page":"Jobs","title":"DFControl.switch_version!","text":"switch_version!(job::DFJob[, version::Int])\n\nSwitches the version of job to one of the previously stored ones. It will save also the current version for future reference.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/#DFControl.rm_version!","page":"Jobs","title":"DFControl.rm_version!","text":"rm_version!(job::DFJob, version::Int)\nrm_versions!(job::DFJob, versions::Int...)\n\nRemoves the specified versions from the job if they exist.\n\n\n\n\n\n","category":"function"},{"location":"guide/jobs/","page":"Jobs","title":"Jobs","text":"More functionality related to versioning will be added in the future.","category":"page"},{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"This page provides a plain list of all inline documention associated with functions, structs  and macros in DFControl. Note that this list is neither structured, complete nor particularly clean, so it only provides rough orientation at the moment. The best reference is the code itself.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"EditURL = \"https://github.com/louisponet/DFControl.jl/blob/master/docs/src/guide/advanced_tutorial.jl\"","category":"page"},{"location":"guide/advanced_tutorial/#Advanced-Usage","page":"Advanced Tutorial","title":"Advanced Usage","text":"","category":"section"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"In this tutorial we will continue from the job created in the Basic Tutorial, and demonstrate some more advanced functionality that DFControl offers.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"To load a previously saved job we here provide a valid job directory with a job.tt script in it.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"using DFControl\n\ntjob = DFJob(joinpath(pathof(DFControl), \"..\", \"..\", \"docs\", \"src\", \"assets\", \"job\"))#hide\ntjob2 = DFJob(joinpath(pathof(DFControl), \"..\", \"..\", \"docs\", \"src\", \"assets\", \"Job2\"))#hide\nif false#hide\n    global job = DFJob(\"job\")\nelse#hide\n    global job = deepcopy(tjob)#hide\n    set_localdir!(job, \"job\") #hide\n    job#hide\nend#hide","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Since the job created in the Basic Tutorial was saved in the \"job\" directory this will work, see the section on Jobs for further details and options on how to load previously saved jobs.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"The next thing we may want to do is to change the directory where the job is running.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"if false#hide\n    set_localdir!(job, \"Job2\"; copy = true)\nelse#hide\n    global job = deepcopy(tjob2)#hide\n    pop!(job)#hide\n    pop!(job)#hide\n    job#hide\nend#hide","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"With the copy=true flag we let DFControl know that not only to create and set the new directory, but also to copy the previous results and temporary files to the new directory so we don't have to rerun the scf calculation.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Next we would like to plot the projected density of states. For that we create both an nscf calculation to get a uniform k-grid, and projwfc calculation.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"push!(job, gencalc_nscf(job[\"scf\"], (6, 6, 6)))","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"The second argument of gencalc_nscf is the kgrid. When passing a 3-Tuple, the code will assume that an explicit k-grid is requested, which can be verified by","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"data(job[\"nscf\"], :k_points)","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Next we generate a projwfc calculation using the fermi level as a guide for the energy window. The arguments are structured as (template, Emin, Emax, deltaE) respectively.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"fermi = readfermi(job)\npush!(job, gencalc_projwfc(job[\"nscf\"], fermi - 10, fermi + 1, 0.1))","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"Next we disable the bands calculation and run the new ones.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"job[\"bands\"].run = false\nif false#hide\n    submit(job)\nelse#hide\n    global job = deepcopy(tjob2)#hide\nend#hide","category":"page"},{"location":"guide/advanced_tutorial/#results_plotting","page":"Advanced Tutorial","title":"Plot Results","text":"","category":"section"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"using Plots\nplot(job, -10, 1)","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"As we can see, again DFControl identifies the additional information that is now present in the job, and uses it to display in the plot.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"In the demonstrated case we see that everything went according to plan, however, often things need to be changed in a trial and error way until the desired results are found.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"On common occurence is that calculation flags have to be set, or changed. This can be done in two ways","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"job[:ecutwfc] = 40.0","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"will go through all the calculations of the job and set the flag if it is allowed, i.e. the flag will not be set in the projwfc calculation since it makes no sense.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"job[\"bands\"][:nbnd] = 30","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"This will set a flag for one specific calculation, again checking whether the flag is valid, and the type will be converted to the correct one.","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"In order to quickly specify what calculations to schedule and which not, one can use","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"set_flow!(job, \"\" => false, \"scf\" => true)","category":"page"},{"location":"guide/advanced_tutorial/","page":"Advanced Tutorial","title":"Advanced Tutorial","text":"As we can see, only the scf and nscf calculations are scheduled to run now, this is because for each of the pairs in the arguments of set_flow!, every calculation inside the job for which the string occurs in the name will be set to run or not depending on the Bool.","category":"page"},{"location":"guide/flags/#Flags","page":"Flags","title":"Flags","text":"","category":"section"},{"location":"guide/structure/#Structure","page":"Structure","title":"Structure","text":"","category":"section"},{"location":"guide/structure/#Contents","page":"Structure","title":"Contents","text":"","category":"section"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"Pages=[\"structure.md\"]","category":"page"},{"location":"guide/structure/#Index","page":"Structure","title":"Index","text":"","category":"section"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"Pages=[\"structure.md\"]","category":"page"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"Structure\nBase.getindex(::Structure, ::Int)\nupdate_geometry!\npolyhedron","category":"page"},{"location":"guide/structure/#DFControl.Structure","page":"Structure","title":"DFControl.Structure","text":"Structure([name::String,] cell::Mat3, atoms::Vector{<:AbstractAtom}[, data::Dict{Symbol,Any}])\n\nThe structure on which the DFCalculations will be performed.\n\nStructure(cif_file::String; name = \"NoName\")\n\nCreates a Structure from the supplied cif file.\n\n\n\n\n\n","category":"type"},{"location":"guide/structure/#Base.getindex-Tuple{Structure, Int64}","page":"Structure","title":"Base.getindex","text":"getindex(structure::AbstractStructure, i::Int)\ngetindex(structure::AbstractStructure, name::Symbol)\ngetindex(structure::AbstractStructure, el::Element)\n\nReturns the ith atom in structure, or all atoms with name or are of element el.\n\n\n\n\n\n","category":"method"},{"location":"guide/structure/#DFControl.update_geometry!","page":"Structure","title":"DFControl.update_geometry!","text":"update_geometry!(str1::AbstractStructure, str2::AbstractStructure)\nupdate_geometry!(job::DFJob, str2::AbstractStructure)\n\nUpdates the spatial parameters of the atoms and cell of the first structure to those found in the second.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFControl.polyhedron","page":"Structure","title":"DFControl.polyhedron","text":"polyhedron(at::AbstractAtom, atoms::Vector{<:AbstractAtom}, order::Int)\npolyhedron(at::AbstractAtom, str::AbstractStructure, order::Int)\n\nReturns a polyhedron around the atom, i.e. the order closest atoms. The returned atoms will be ordered according to their distance to the first one. In the case of a structure rather than a set of atoms, the search will be performed over all atoms in the structure.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#Symmetries","page":"Structure","title":"Symmetries","text":"","category":"section"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"This functionality relies on spglib to find the symmetries of the Structure and  supply various related quantities.","category":"page"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"high_symmetry_kpath\nhigh_symmetry_kpoints\ninternational\nniggli_reduce\nsymmetry_operators","category":"page"},{"location":"guide/structure/#DFControl.high_symmetry_kpath","page":"Structure","title":"DFControl.high_symmetry_kpath","text":"high_symmetry_kpath(s::AbstractStructure, npoints_per_segment::Int; package=QE, kwargs...)\nhigh_symmetry_kpath(j::DFJob, npoints_per_segment::Int; package=QE, kwargs...)\n\nGenerates a QE bands calculation compliant high symmetry kpath, to be used with e.g. set_kpoints!(bands_calculation, kpoints). \n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFControl.high_symmetry_kpoints","page":"Structure","title":"DFControl.high_symmetry_kpoints","text":"high_symmetry_kpoints(s::Structure; tolerance = 1e-5)\nhigh_symmetry_kpoints(j::DFJob; tolerance = 1e-5)\n\nReturns (kpoints, path) where kpoints are the high-symmetry k-points, and path are the sections of the high symmetry path through the first Brillouin Zone.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFControl.international","page":"Structure","title":"DFControl.international","text":"international(j::DFJob; tolerance=1.0e-5)\ninternational(s::Structure; tolerance=1.0e-5)\n\nReturns the international symbol of the space group of the structure.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFControl.niggli_reduce","page":"Structure","title":"DFControl.niggli_reduce","text":"niggli_reduce(j::DFJob; tolerance=1.0e-5)\nniggli_reduce(s::Structure; tolerance=1.0e-5)\n\nReturns the niggli reduced Structure.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFControl.symmetry_operators","page":"Structure","title":"DFControl.symmetry_operators","text":"symmetry_operators(j::DFJob; maxsize=52, tolerance=1.0e-5)\nsymmetry_operators(s::Structure; maxsize=52, tolerance=1.0e-5)\n\nFinds and returns all the rotations and translations that are symmetry operators of the structure.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#Cell","page":"Structure","title":"Cell","text":"","category":"section"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"note: Note\nThe lattice vectors are stored as the columns of the cell.","category":"page"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"a\nb\nc\ncell_parameters\nvolume\ncreate_supercell\nscale_cell!","category":"page"},{"location":"guide/structure/#DFControl.a","page":"Structure","title":"DFControl.a","text":"a(str::AbstractStructure)\n\nFirst lattice vector.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFControl.b","page":"Structure","title":"DFControl.b","text":"b(str::AbstractStructure)\n\nSecond lattice vector.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFControl.c","page":"Structure","title":"DFControl.c","text":"c(str::AbstractStructure)\n\nThird lattice vector.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFControl.cell_parameters","page":"Structure","title":"DFControl.cell_parameters","text":"cell_parameters(cell::Mat3)\ncell_parameters(str::Structure)\n\nParameters (a, b, c, α, β, γ)of the calculation cell returned in a NamedTuple.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFControl.volume","page":"Structure","title":"DFControl.volume","text":"volume(cell::Mat3)\nvolume(str::Structure)\nvolume(job::DFJob)\n\nCalculates the volume for the unit cell.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFControl.create_supercell","page":"Structure","title":"DFControl.create_supercell","text":"create_supercell(structure::AbstractStructure, na::Int, nb::Int, nc::Int; make_afm=false)\ncreate_supercell(structure::AbstractStructure, na::UnitRange, nb::UnitRange, nc::UnitRange; make_afm=false)\n\nTakes a structure and creates a supercell from it with: the given amount of additional cells if (na::Int, nb::Int, nc::Int) along the a, b, c direction, or amount of cells specified by the ranges i.e. -1:1, -1:1, -1:1 would create a 3x3x3 supercell. If make_afm is set to true all the labels and magnetizations of the magnetic atoms will be reversed in a checkerboard fashion.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFControl.scale_cell!","page":"Structure","title":"DFControl.scale_cell!","text":"scale_cell!(structure::Structure, scalemat::Matrix)\nscale_cell!(job::DFJob, scalemat::Matrix)\n\nRescales the cell of the structure.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#Atom","page":"Structure","title":"Atom","text":"","category":"section"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"Atom\natoms(::Structure)\nset_position!","category":"page"},{"location":"guide/structure/#DFControl.Atom","page":"Structure","title":"DFControl.Atom","text":"Atom(name::Symbol, element::Element, position_cart::Point3{Length}, position_cryst::Point3;\n     pseudo::Pseudo = Pseudo(),\n     projections::Vector{Projection} = Projection[],\n     magnetization::Vec3 = Vec3(0.0, 0.0, 0.0),\n     dftu::DFTU = DFTU())\n\nRepresentation of an atom.\n\nThe name of the atom is used as an identifier for the atom type, in the sense that atoms with the same pseudo, projections, magnetization and dftu attributes should belong to the same type. This also means that during sanity checks atoms that are not of the same type will be given different names. This is done in this way because it often makes sense to change these parameters on all atoms of the same kind at the same time, but still allow the flexibility to change them for individual atoms as well.\n\nposition_cart should have a valid Unitful.Length type such as Ang.\n\nSee documentation for Element and Pseudo for further information on these attributes.\n\n\n\n\n\n","category":"type"},{"location":"guide/structure/#DFControl.atoms-Tuple{Structure}","page":"Structure","title":"DFControl.atoms","text":"atoms([f::Function,], structure::AbstractStructure)\n\nReturns structure.atoms or filter(f, structure.atoms) if f is specified.\n\n\n\n\n\n","category":"method"},{"location":"guide/structure/#DFControl.set_position!","page":"Structure","title":"DFControl.set_position!","text":"set_position!(at::AbstractAtom, pos::AbstractVector{T}, unit_cell::Mat3) where {T<:Real}\n\nUpdates the position of the atom to this. The unit cell is used to make sure both position_cryst and position_cart are correct.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#Element","page":"Structure","title":"Element","text":"","category":"section"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"DFControl.Element\nelement","category":"page"},{"location":"guide/structure/#DFControl.Element","page":"Structure","title":"DFControl.Element","text":"Element(symbol::Symbol, Z::Int, name::String, atomic_weight::Float64, color::NTuple{3, Float64})\n\nRepresents an element. Most conveniently used trough the function element.\n\n\n\n\n\n","category":"type"},{"location":"guide/structure/#DFControl.element","page":"Structure","title":"DFControl.element","text":"element(sym::Symbol)\n\nReturns the predefined Element with symbol sym, i.e. element(:Si) will return the pregenerated Silicon Element.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#pseudo_header","page":"Structure","title":"Pseudo Potentials","text":"","category":"section"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"Pseudo\nset_pseudo!\nset_pseudos!\nlist_pseudosets","category":"page"},{"location":"guide/structure/#DFControl.Pseudo","page":"Structure","title":"DFControl.Pseudo","text":"Pseudo(name::String, dir::String)\n\nA pseudo potential file.\n\n\n\n\n\n","category":"type"},{"location":"guide/structure/#DFControl.set_pseudo!","page":"Structure","title":"DFControl.set_pseudo!","text":"set_pseudo!(at::AbstractAtom, pseudo::Pseudo; print=true)\n\nSets the pseudopotential at to pseudo, and the validity of the Pseudo is checked.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFControl.set_pseudos!","page":"Structure","title":"DFControl.set_pseudos!","text":"set_pseudos!(job::DFJob, set::Symbol, specifier::String=\"\"; kwargs...)\nset_pseudos!(structure::AbstractStructure, set::Symbol, specifier::String=\"\"; kwargs...)\nset_pseudos!(job::DFJob, atsym::Symbol, set::Symbol, specifier::String=\"\"; kwargs...)\nset_pseudos!(structure::AbstractStructure, atsym::Symbol, set::Symbol, specifier::String=\"\"; kwargs...)\n\nSets the pseudopotentials of the atoms inside the structure (or job.structure) to the ones of set. specifier can be specified to select a specific pseudo if multiple pseudopotentials for a given element exist in the set. Example:\n\nset_pseudos!(job, :pbesol, \"rrkjus\")\n\nwill select the pseudo file that contains \"rrkjus\" in the filename.\n\nIf atsym is used, only the pseudos of the atoms with that name will be set.\n\nset_pseudos!(job::DFJob, at_pseudos::Pair{Symbol, Pseudo}...; kwargs...)\nset_pseudos!(structure::AbstractStructure, at_pseudos::Pair{Symbol, Pseudo}...; kwargs...)\n\nConvenience function that allows to set pseudopotentials for multiple atom types at the same time. e.g. `setpseudos!(job, :Si => getdefaultpseudo(:Si, :sssp)\n\n\n\n\n\nsets the pseudopotentials for the atom with name atsym to the specified one in the default pseudoset.\n\n\n\n\n\nsets the pseudopotentials to the specified one in the default pseudoset.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFControl.list_pseudosets","page":"Structure","title":"DFControl.list_pseudosets","text":"list_pseudosets()\n\nLists the pseudosets that have previously been set up.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"note: Note\n","category":"page"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"If pseudopotentials from different sets/directories are specified for the atoms, they will be  copied to the DFJob local_dir.","category":"page"},{"location":"guide/structure/#Pseudo-sets","page":"Structure","title":"Pseudo sets","text":"","category":"section"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"See the section on Configuration for a demonstration on how to set up pseudopotential sets.","category":"page"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"getdefault_pseudo\nsetdefault_pseudodir\nconfiguredefault_pseudos","category":"page"},{"location":"guide/structure/#DFControl.getdefault_pseudo","page":"Structure","title":"DFControl.getdefault_pseudo","text":"getdefault_pseudo(atom::Symbol, set=:default; specifier=nothing)\n\nReturns the pseudo potential string linked to the atom.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFControl.setdefault_pseudodir","page":"Structure","title":"DFControl.setdefault_pseudodir","text":"setdefault_pseudodir(pseudo_symbol::Symbol, dir::String)\n\nAdds an entry inside the default_pseudodirs with flag pseudo_symbol, and adds it to the user_defaults.jl file.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFControl.configuredefault_pseudos","page":"Structure","title":"DFControl.configuredefault_pseudos","text":"configuredefault_pseudos(server = getdefault_server(), pseudo_dirs=getdefault_pseudodirs())\n\nReads the specified default_pseudo_dirs on the default_server and sets up the default_pseudos variable, and also adds all the entries to the user_defaults.jl file.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#Magnetization","page":"Structure","title":"Magnetization","text":"","category":"section"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"Magnetization can be set on a per Atom basis. It will partially determine the unique Atom types and also what calculation flags should be set in order to allow for the  magnetic calculation (either colinear or non-colinear).","category":"page"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"set_magnetization!","category":"page"},{"location":"guide/structure/#DFControl.set_magnetization!","page":"Structure","title":"DFControl.set_magnetization!","text":"set_magnetization!(at::AbstractAtom, mag; print=true)\n\nSets the magnetization of the Atom.\n\nset_magnetization!(str::Structure, atsym_mag::Pair{Symbol,<:AbstractVector}...)\nset_magnetization!(job::DFJob, atsym_mag::Pair{Symbol,<:AbstractVector}...)\n\nEach of the names in atsym_mag will be matched with the Atoms and their magnetization will be set to the specified ones.\n\nExample:\n\nset_magnetization!(job, :Ni1 => [0.0, 0.0, -1.0], :Ni2 => [0.0, 0.0, 1.0])\n\nwill set all the moments of Atoms with name Ni1 to [0.0, 0.0, -1.0] and Ni2 to [0.0, 0.0, 1.0]. Since the moments are aligned with the z-direction this will signal that colinear calculations should be ran.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#Projections","page":"Structure","title":"Projections","text":"","category":"section"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"These projections will mainly be used for generating Wannier90 inputs, and to distinguish which indices in the Wannier90 output matrices correspond to the various atoms/orbitals.","category":"page"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"Projection\nset_projections!","category":"page"},{"location":"guide/structure/#DFControl.Projection","page":"Structure","title":"DFControl.Projection","text":"Projection(orb::Orbital, start::Int, last::Int)\n\nA Wannier90 Projection, representing an Orbital with indices from start to last.\n\n\n\n\n\n","category":"type"},{"location":"guide/structure/#DFControl.set_projections!","page":"Structure","title":"DFControl.set_projections!","text":"set_projections!(at::AbstractAtom, projections::Vector{Projection}; print=true)\n\nSets the projections of the atom.\n\nset_projections!(str::Structure, projs::Pair...; soc=false)\nset_projections!(job::DFJob, projs::Pair...; kwargs...)\n\nSets the projections of the specified atoms. projs has to be of form :atsym => [:proj], where proj = \"s\", \"p\", \"d\", \"f\", see Orbital to see which projections are allowed.  If soc is set to true both up and down projections will be taken into account.\n\nnote: Note\nThe previously existing projections will be overwritten when using the last two functions.\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#Orbitals","page":"Structure","title":"Orbitals","text":"","category":"section"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"Orbital\norbital","category":"page"},{"location":"guide/structure/#DFControl.Orbital","page":"Structure","title":"DFControl.Orbital","text":"Orbital(name::String, size::Int, l::Int, mr::Int)\n\nWannier90 orbital as defined in the Wannier90 User Guide. The name will be written in the projections block of the Wannier90 input.\n\n\n\n\n\n","category":"type"},{"location":"guide/structure/#DFControl.orbital","page":"Structure","title":"DFControl.orbital","text":"orbital(s::String)\n\nReturns the Orbital identified by s. \n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFT-U","page":"Structure","title":"DFT + U","text":"","category":"section"},{"location":"guide/structure/","page":"Structure","title":"Structure","text":"DFTU\nset_Hubbard_U!\nset_Hubbard_J0!\nset_Hubbard_α!\nset_Hubbard_β!\nset_Hubbard_J!","category":"page"},{"location":"guide/structure/#DFControl.DFTU","page":"Structure","title":"DFControl.DFTU","text":"DFTU(;l ::Int = -1,\n      U ::T   = zero(T),\n      J0::T  = zero(T),\n      α ::T   = zero(T),\n      β ::T   = zero(T),\n      J ::Vector{T} = T[zero(T)])\n\nDFT+U parameters for a given Atom.\n\n\n\n\n\n","category":"type"},{"location":"guide/structure/#DFControl.set_Hubbard_U!","page":"Structure","title":"DFControl.set_Hubbard_U!","text":"setHubbardU!(at::AbstractAtom, v::AbstractFloat; print=true)          setHubbardU!(job::DFJob, ats_Us::Pair{Symbol, <:AbstractFloat}...; print=true)\n\n Set the Hubbard U parameter for the specified [Atoms](@ref Atom).\n The latter function allows for conveniently setting the parameter for all\n [Atoms](@ref Atom) with the specified `name`.\n\n Example:\n     `set_Hubbard_U!(job, :Ir => 2.1, :Ni => 1.0, :O => 0.0)`\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFControl.set_Hubbard_J0!","page":"Structure","title":"DFControl.set_Hubbard_J0!","text":"setHubbardJ0!(at::AbstractAtom, v::AbstractFloat; print=true)          setHubbardJ0!(job::DFJob, ats_J0s::Pair{Symbol, <:AbstractFloat}...; print=true)\n\n Set the Hubbard J0 parameter for the specified [Atoms](@ref Atom).\n The latter function allows for conveniently setting the parameter for all\n [Atoms](@ref Atom) with the specified `name`.\n\n Example:\n     `set_Hubbard_J0!(job, :Ir => 2.1, :Ni => 1.0, :O => 0.0)`\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFControl.set_Hubbard_α!","page":"Structure","title":"DFControl.set_Hubbard_α!","text":"setHubbardα!(at::AbstractAtom, v::AbstractFloat; print=true)          setHubbardα!(job::DFJob, ats_αs::Pair{Symbol, <:AbstractFloat}...; print=true)\n\n Set the Hubbard α parameter for the specified [Atoms](@ref Atom).\n The latter function allows for conveniently setting the parameter for all\n [Atoms](@ref Atom) with the specified `name`.\n\n Example:\n     `set_Hubbard_α!(job, :Ir => 2.1, :Ni => 1.0, :O => 0.0)`\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFControl.set_Hubbard_β!","page":"Structure","title":"DFControl.set_Hubbard_β!","text":"setHubbardβ!(at::AbstractAtom, v::AbstractFloat; print=true)          setHubbardβ!(job::DFJob, ats_βs::Pair{Symbol, <:AbstractFloat}...; print=true)\n\n Set the Hubbard β parameter for the specified [Atoms](@ref Atom).\n The latter function allows for conveniently setting the parameter for all\n [Atoms](@ref Atom) with the specified `name`.\n\n Example:\n     `set_Hubbard_β!(job, :Ir => 2.1, :Ni => 1.0, :O => 0.0)`\n\n\n\n\n\n","category":"function"},{"location":"guide/structure/#DFControl.set_Hubbard_J!","page":"Structure","title":"DFControl.set_Hubbard_J!","text":"set_Hubbard_J!(at::AbstractAtom, v::Vector{<:AbstractFloat}; print=true)\nset_Hubbard_J!(job::DFJob, ats_Js::Pair{Symbol, Vector{<:AbstractFloat}}...; print=true)\n\nSet the Hubbard J parameter for the specified atom. The latter function allows for conveniently setting the Hubbard_J for all Atoms with the specified name.\n\nExample: \tset_Hubbard_J(at, [2.1])'setHubbardJ(job, :Ir => [2.1], :Ni => [1.0])'\n\n\n\n\n\n","category":"function"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"EditURL = \"https://github.com/louisponet/DFControl.jl/blob/master/docs/src/guide/basic_tutorial.jl\"","category":"page"},{"location":"guide/basic_tutorial/#Basic-Tutorial","page":"Basic Tutorial","title":"Basic Tutorial","text":"","category":"section"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Since DFControl is aimed at improving the day to day quality of life of a material's scientist/anyone running DFT codes, we will look at a simple demonstration of how by creating and submitting some Quantum-Espresso calculations on Si starting from a cif file specifying the structure.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"using DFControl","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"First we download the cif file, extract the Structure and assign the right pseudos to it. In this case Si (F d -3 m :1) from http://www.crystallography.net/cod/9011998.cif","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"using Downloads\ncif_file = Downloads.download(\"http://www.crystallography.net/cod/9011998.cif\", \"Si.cif\")\n\nstructure = Structure(cif_file; name = \"Si\")\nset_pseudos!(structure, :pbesol)","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"This assumes that the :pbesol pseudopotential set was installed during the configuration step.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Next we specify the executables with which to run the QE calculations. We assume here that mpirun is installed and in the user's PATH, and that QE is installed, and to be found in the /opt/qe/bin, change this according to your own setup.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"pw_execs = [Exec(\"mpirun\", \"\", :np => 4), Exec(\"pw.x\", \"/opt/qe/bin/\", :nk => 4)]","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Additional executable flags can be passed as varargs to the constructor of Exec, e.g. Exec(\"pw.x\", \"/opt/qe/bin/\", :nk => 4, :ndiag => 2).","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Then we create the first calculation for our job, we name it scf, which will be used to reference it later. We also pass the executables to be used and additional flags to be set to the constructor. Afterwards we set the kpoints to be used in the scf calculation.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"scf_calculation = DFCalculation{QE}(\"scf\", :calculation => \"scf\"; execs = pw_execs)\nset_kpoints!(scf_calculation, (6, 6, 6, 1, 1, 1))","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"The code recognizes internally that this 6-Tuple corresponds to a K_POINTS (automatic) block in QE. Alternatively (leading to an identical final result):","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"scf_calculation = DFCalculation{QE}(\"scf\", :calculation => \"scf\"; execs = pw_execs,\n                                    data = [InputData(:k_points, :automatic,\n                                                      (6, 6, 6, 1, 1, 1))])","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"We can now define our job:","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"job = DFJob(\"Si\", structure, [scf_calculation], :ecutwfc => 20, :conv_thr => 1e-6;\n            local_dir = \"job\")","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Additional calculations would be be added to the list [scf_calculation]. The flag => value pairs will set the specified flags to that value for all calculations in the job that allow recognize that flag, so it's ideal for things like cutoffs and smearing etc.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"We are now ready to submit the job, which will run in the current working directory","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"if false #hide\n    submit(job)\nelse #hide\n    global job = DFJob(joinpath(@__DIR__, \"../../src/assets/job/\"))#hide\n    pop!(job) #hide\nend #hide","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"This will generate and save all calculation files, and the corresponding job script (job.tt), and subsequently run the job. First submission through sbatch job.tt will be tried, if that fails then the script will run through bash job.tt.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"After the job finishes the outputs can be parsed through","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"outputdata(job)","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"or for a specific calculation","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"outputdata(job[\"scf\"])","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"This also demonstrates how a calculation can be referenced using its name (remember that we named the calculation \"scf\" when creating it).","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Now that the scf calculation finished succesfully, the next step is usually to have a look at the bandstructure. For this we generate a bands calculation, using the scf calculation as a template and a generated high symmetry k-point path with 20 kpoints per segment.","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"bands_calc = gencalc_bands(job[\"scf\"], high_symmetry_kpath(job.structure, 20))","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Observe the :calculation => \"bands\", and automatic setting of the :verbosity => \"high\" flags. We now push! this calculation to the job queue","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"push!(job, bands_calc)","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"However, since we know the scf succeeded there is no need to rerun it. To un-schedule it we do","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"job[\"scf\"].run = false","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Printing the job will now highlight the scheduled calculations differently from the non-scheduled ones","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"job","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Seeing that all is right we submit the job again","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"set_localdir!(job, \"job\"); #hide\nif false #hide\n    submit(job)\nelse #hide\n    global job = DFJob(joinpath(pathof(DFControl), \"..\", \"..\", \"docs\", \"src\", \"assets\",\n                                \"job\"))#hide\nend #hide","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"We can access the bands through","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"bands = readbands(job);\nnothing #hide","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"or","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"bands = outputdata(job[\"bands\"])[:bands];\nnothing #hide","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"They can be plotted too","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"fermi = readfermi(job) # = outputdata(job[\"scf\"])[:fermi]\nusing Plots\nplot(bands; fermi = fermi)","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"Since more info (such as the structure) is available in the job, plotting the job leads to a richer plot","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"plot(job, -10, 1)","category":"page"},{"location":"guide/basic_tutorial/","page":"Basic Tutorial","title":"Basic Tutorial","text":"As can be seen in the Advanced Usage, additional information generated by additional calculations will be picked up by DFControl in order to create richer plots.","category":"page"},{"location":"guide/calculations/#Calculations","page":"Calculations","title":"Calculations","text":"","category":"section"},{"location":"guide/calculations/#Contents","page":"Calculations","title":"Contents","text":"","category":"section"},{"location":"guide/calculations/","page":"Calculations","title":"Calculations","text":"Pages=[\"calculations.md\"]","category":"page"},{"location":"guide/calculations/#Index","page":"Calculations","title":"Index","text":"","category":"section"},{"location":"guide/calculations/","page":"Calculations","title":"Calculations","text":"Pages=[\"calculations.md\"]","category":"page"},{"location":"guide/calculations/","page":"Calculations","title":"Calculations","text":"DFCalculation\nInputData","category":"page"},{"location":"guide/calculations/#DFControl.DFCalculation","page":"Calculations","title":"DFControl.DFCalculation","text":"DFCalculation{P<:Package}(name    ::String;\n                          dir     ::String = \"\",\n                          flags   ::AbstractDict = Dict{Symbol, Any}(),\n                          data    ::Vector{InputData} = InputData[],\n                          execs   ::Vector{Exec},\n                          run     ::Bool = true,\n                          outdata ::AbstractDict = Dict{Symbol, Any}(),\n                          infile  ::String = P == Wannier90 ? name * \".win\" : name * \".in\",\n                          outfile ::String = name * \".out\")\n\nThe representation of a DFT calculation of package P, holding the flags that will be written to the infile, the executables in execs and the output written by the calculation to the outfile. It essentially represents a line in a job script similar to exec1 exec2 < infile.in > outfile.out.  outdata stores the parsed calculation output after it was read at least once. The run field indicates whether the calculation should be actually performed, e.g. if run=false the corresponding line will be commented out in the job script.\n\nDFCalculation{P<:Package}(name::AbstractString, flags::Pair{Symbol, Any}...; kwargs...)\n\nCreate a DFCalculation from name and flags, other kwargs... will be passed to the constructor.\n\nDFCalculation(template::DFCalculation, name::AbstractString, flags::Pair{Symbol, Any}...; excs=deepcopy(execs(template)), run=true, data=nothing, dir=copy(template.dir))\n\nCreates a new DFCalculation from the template, setting the flags of the newly created one to the specified ones.\n\n\n\n\n\n","category":"type"},{"location":"guide/calculations/#DFControl.InputData","page":"Calculations","title":"DFControl.InputData","text":"InputData(name::Symbol, option::Symbol, data::Any)\n\nRepresents a more structured block of input data. e.g. InputData(:k_points, :automatic, (6,6,6,1,1,1)) would be translated for a QE calculation into\n\nK_POINTS(automatic)\n6 6 6 1 1 1\n\n\n\n\n\n","category":"type"},{"location":"guide/calculations/#Basic-interaction","page":"Calculations","title":"Basic interaction","text":"","category":"section"},{"location":"guide/calculations/","page":"Calculations","title":"Calculations","text":"set_name!\ndata\nset_data!\nset_data_option!\nset_kpoints!","category":"page"},{"location":"guide/calculations/#DFControl.set_name!","page":"Calculations","title":"DFControl.set_name!","text":"set_name!(calculation::DFCalculation, name::AbstractString)\n\nSets calculation.name, and calculation.infile and calculation.outfile to conform with the new name.\n\n\n\n\n\n","category":"function"},{"location":"guide/calculations/#DFControl.data","page":"Calculations","title":"DFControl.data","text":"data(calculation::DFCalculation)\ndata(calculation::DFCalculation, n::Symbol)\n\nThe former returns calculation.data, the later – the InputData with name n.\n\n\n\n\n\n","category":"function"},{"location":"guide/calculations/#DFControl.set_data!","page":"Calculations","title":"DFControl.set_data!","text":"set_data!(calculation::DFCalculation, data::InputData)\n\nIf an InputData with the same name as data is already in calculation, it will be overwritten. Otherwise data gets pushed to the list of InputData blocks.\n\n\n\n\n\nset_data!(calculation::DFCalculation, block_name::Symbol, new_block_data; option::Symbol=nothing, print::Bool=true)\n\nSearches for an InputData for which InputData.name == block_name, and sets DFInput.data = new_block_data. If option is specified it is set, i.e. InputData.option = option.\n\n\n\n\n\nset_data!(job::DFJob, calculations::Vector{<:DFCalculation}, dataname::Symbol, data; option=nothing)\n\nLooks through the calculation filenames and sets the data of the datablock with data_block_name to new_block_data. if option is specified it will set the block option to it.\n\n\n\n\n\n","category":"function"},{"location":"guide/calculations/#DFControl.set_data_option!","page":"Calculations","title":"DFControl.set_data_option!","text":"set_data_option!(calculation::DFCalculation, name::Symbol, option::Symbol; print=true)\n\nSearches for an InputData for which InputData.name == block_name, and sets InputData.option = option.\n\n\n\n\n\nset_data_option!(job::DFJob, names::Vector{String}, dataname::Symbol, option::Symbol)\n\nsets the option of specified data in the specified calculations.\n\n\n\n\n\nset_data_option!(job::DFJob, name::Symbol, option::Symbol)\n\nsets the option of specified data block in all calculations that have the block.\n\n\n\n\n\n","category":"function"},{"location":"guide/calculations/#DFControl.set_kpoints!","page":"Calculations","title":"DFControl.set_kpoints!","text":"set_kpoints!(calculation::DFCalculation{QE}, k_grid::NTuple{3, Int}; print=true)\nset_kpoints!(calculation::DFCalculation{QE}, k_grid::NTuple{6, Int}; print=true)\nset_kpoints!(calculation::DFCalculation{QE}, k_grid::Vector{<:NTuple{4}}; print=true, k_option=:crystal_b)\n\nConvenience function to set the :k_points data block of calculation. The three different methods are targeted at nscf, scf or vcrelax, and bands calculations, respectively. For the nscf version an explicit list of k_points will be generated.\n\nset_kpoints!(calculation::DFCalculation{Wannier90}, k_grid::NTuple{3, Int})\n\nSimilar to the nscf targeted function in the sense that it will generate an explicit list of k_points, adhering to the same rules as for the nscf. The mp_grid flag will also automatically be set.\n\n\n\n\n\n","category":"function"},{"location":"guide/calculations/#Flags","page":"Calculations","title":"Flags","text":"","category":"section"},{"location":"guide/calculations/","page":"Calculations","title":"Calculations","text":"A big part of working with DFT calculations is specifying the various calculation flags. Remembering all the names of the flags, where they belong, and what types they are expected to be, is quite complicated and can lead to easily made mistakes like typos. DFControl tries to catch these as it knows which flags are allowed for which calculations. It will report when a flag can not be found for a given DFCalculation, and it will also try to convert a flag value to the expected type.","category":"page"},{"location":"guide/calculations/","page":"Calculations","title":"Calculations","text":"Base.getindex(::DFCalculation, ::Symbol)\nBase.setindex!(::DFCalculation, ::Symbol, ::Any)\nset_flags!\nrm_flags!","category":"page"},{"location":"guide/calculations/#Base.getindex-Tuple{DFCalculation, Symbol}","page":"Calculations","title":"Base.getindex","text":"getindex(calculation::DFCalculation, n::Symbol)\n\nReturns the flag with given symbol.\n\ngetindex(job::DFJob, flag::Symbol)\n\nSearches through the job's calculations for the requested flag. A Dict will be returned with calculation names as the keys and the flags as values.\n\n\n\n\n\n","category":"method"},{"location":"guide/calculations/#Base.setindex!-Tuple{DFCalculation, Symbol, Any}","page":"Calculations","title":"Base.setindex!","text":"setindex!(calculation::DFCalculation, value, flag::Symbol)\n\nSets flags.\n\nsetindex!(job::DFJob, value, flag::Symbol)\n\nSet flag in all the appropriate calculations to the value.\n\n\n\n\n\n","category":"method"},{"location":"guide/calculations/#DFControl.set_flags!","page":"Calculations","title":"DFControl.set_flags!","text":"set_flags!(calculation::DFCalculation, flags::Pair{Symbol, Any}...; print=true)\n\nSets multiple flags in one go. Flag validity and type are verified.\n\nset_flags!(job::DFJob, calculations::Vector{<:DFCalculation}, flags::Pair{Symbol,<:Any}...; print=true)\nset_flags!(job::DFJob, flags::Pair{Symbol,<:Any}...; print=true)\n\nSets the flags in the names to the flags specified. This only happens if the specified flags are valid for the names.\n\nThe values that are supplied will be checked whether they are valid.\n\n\n\n\n\n","category":"function"},{"location":"guide/calculations/#DFControl.rm_flags!","page":"Calculations","title":"DFControl.rm_flags!","text":"rm_flags!(calculation::DFCalculation, flags::Symbol...)\nrm_flags!(job::DFJob, flags::Symbol...)\n\nRemove the specified flags.\n\n\n\n\n\n","category":"function"},{"location":"guide/calculations/#Execs","page":"Calculations","title":"Execs","text":"","category":"section"},{"location":"guide/calculations/","page":"Calculations","title":"Calculations","text":"Exec\nexec\nexecs\nset_execdir!\nset_execflags!\nrm_execflags!","category":"page"},{"location":"guide/calculations/#DFControl.Exec","page":"Calculations","title":"DFControl.Exec","text":"Exec(;exec::String = \"\", dir::String = \"\", flags::Vector{ExecFlag} = ExecFlag[])\n\nRepresentation of an executable that will run the DFCalculation. Basically dir/exec --<flags> inside a job script.\n\nExec(exec::String, dir::String, flags::Pair{Symbol}...)\n\nWill first transform flags into a Vector{ExecFlag}, and construct the Exec. \n\n\n\n\n\n","category":"type"},{"location":"guide/calculations/#DFControl.exec","page":"Calculations","title":"DFControl.exec","text":"exec(calculation::DFCalculation, exec::String)\nexec(job::DFJob, exec::String)\n\nConvenience function that returns the first executable in calculation or job for which exec occursin the name.\n\n\n\n\n\n","category":"function"},{"location":"guide/calculations/#DFControl.execs","page":"Calculations","title":"DFControl.execs","text":"execs(calculation::DFCalculation, exec::String)\nexecs(job::DFJob, exec::String)\n\nConvenience function to filter all executables in calculation or job for which exec occurs in the executable name.\n\n\n\n\n\n","category":"function"},{"location":"guide/calculations/#DFControl.set_execdir!","page":"Calculations","title":"DFControl.set_execdir!","text":"set_execdir!(calculation::DFCalculation, exec::String, dir::String)\nset_execdir!(job::DFJob, exec::String, dir::String)\n\nGoes through the execs in calculation or job and sets the dir if the executable name contains exec.\n\nExample:\n\nset_execdir!(calculation, \"pw.x\", \"/path/to/QE/bin\")\nset_execdir!(job, \"pw.x\", \"/path/to/QE/bin\")\n\n\n\n\n\n","category":"function"},{"location":"guide/calculations/#DFControl.set_execflags!","page":"Calculations","title":"DFControl.set_execflags!","text":"set_execflags!(calculation::DFCalculation, exec::String, flags::Pair...)\nset_execflags!(job::DFJob, exec::String, flags::Pair...)\n\nGoes through the execs in calculation or job and sets the flags if the executable name contains exec.\n\n\n\n\n\n","category":"function"},{"location":"guide/calculations/#DFControl.rm_execflags!","page":"Calculations","title":"DFControl.rm_execflags!","text":"rm_execflags!(calculation::DFCalculation, exec::String, flags...)\nrm_execflags!(job::DFJob, exec::String, flags...)\n\nGoes through the execs in calculation or job and removes the flags if the executable name contains exec.\n\n\n\n\n\n","category":"function"},{"location":"guide/calculations/#calculation_generation","page":"Calculations","title":"Generating new calculations","text":"","category":"section"},{"location":"guide/calculations/","page":"Calculations","title":"Calculations","text":"gencalc_vcrelax(::DFCalculation{QE}, ::NTuple{6, Int}, ::Any...)\ngencalc_scf(::DFCalculation{QE}, ::NTuple{6, Int}, ::Any...)\ngencalc_bands(::DFCalculation{QE}, ::Vector{<:NTuple{4}}, ::Any...)\ngencalc_nscf(::DFCalculation{QE}, kpoints::NTuple{3, Int}, ::Any...)\ngencalc_projwfc(::DFCalculation{QE}, ::Real, ::Real, ::Real)\ngencalc_wan","category":"page"},{"location":"guide/calculations/#DFControl.gencalc_vcrelax-Tuple{DFCalculation{QE}, NTuple{6, Int64}, Vararg{Any, N} where N}","page":"Calculations","title":"DFControl.gencalc_vcrelax","text":"gencalc_vcrelax(template::DFCalculation{QE}, kpoints::NTuple{6, Int}, newflags...; name=\"scf\")\n\nUses the information from the template and supplied kpoints to generate a vcrelax calculation. Extra flags can be supplied which will be set for the generated calculation.\n\n\n\n\n\n","category":"method"},{"location":"guide/calculations/#DFControl.gencalc_scf-Tuple{DFCalculation{QE}, NTuple{6, Int64}, Vararg{Any, N} where N}","page":"Calculations","title":"DFControl.gencalc_scf","text":"gencalc_scf(template::DFCalculation{QE}, kpoints::NTuple{6, Int}, newflags...; name=\"scf\")\n\nUses the information from the template and supplied kpoints to generate an scf calculation. Extra flags can be supplied which will be set for the generated calculation.\n\n\n\n\n\n","category":"method"},{"location":"guide/calculations/#DFControl.gencalc_bands-Tuple{DFCalculation{QE}, Vector{var\"#s3\"} where var\"#s3\"<:(NTuple{4, T} where T), Vararg{Any, N} where N}","page":"Calculations","title":"DFControl.gencalc_bands","text":"gencalc_bands(template::DFCalculation{QE}, kpoints::Vector{NTuple{4}}, newflags...; name=\"bands\")\n\nUses the information from the template and supplied kpoints to generate a bands calculation. Extra flags can be supplied which will be set for the generated calculation.\n\n\n\n\n\n","category":"method"},{"location":"guide/calculations/#DFControl.gencalc_nscf-Tuple{DFCalculation{QE}, Tuple{Int64, Int64, Int64}, Vararg{Any, N} where N}","page":"Calculations","title":"DFControl.gencalc_nscf","text":"gencalc_nscf(template::DFCalculation{QE}, kpoints::NTuple{3, Int}, newflags...; name=\"nscf\")\n\nUses the information from the template and supplied kpoints to generate an nscf calculation. Extra flags can be supplied which will be set for the generated calculation.\n\n\n\n\n\n","category":"method"},{"location":"guide/calculations/#DFControl.gencalc_projwfc-Tuple{DFCalculation{QE}, Real, Real, Real}","page":"Calculations","title":"DFControl.gencalc_projwfc","text":"gencalc_projwfc(template::DFCalculation{QE}, Emin, Emax, DeltaE, newflags...; name=\"projwfc\")\n\nUses the information from the template and supplied kpoints to generate a projwfc.x calculation. Extra flags can be supplied which will be set for the generated calculation.\n\n\n\n\n\n","category":"method"},{"location":"guide/calculations/#DFControl.gencalc_wan","page":"Calculations","title":"DFControl.gencalc_wan","text":"gencalc_wan(nscf::DFCalculation{QE}, structure::AbstractStructure, Emin, wanflags...;\n            Epad     = 5.0,\n            wanexec  = Exec(exec=\"wannier90.x\", dir=\"\"))\n\nGenerates a Wannier90 calculation to follow on the supplied nscf calculation. It uses the projections defined in the structure, and starts counting the required amount of bands from Emin. The nscf needs to have a valid output since it will be used in conjunction with Emin to find the required amount of bands and energy window for the Wannier90 calculation.\n\n\n\n\n\ngencalc_wan(nscf::DFCalculation{QE}, structure::AbstractStructure, projwfc::DFCalculation{QE}, threshold::Real, wanflags...; kwargs...)\n\nGenerates a wannier calculation, that follows on the nscf calculation. Instead of passing Emin manually, the output of a projwfc.x run can be used together with a threshold to determine the minimum energy such that the contribution of the projections to the DOS is above the threshold.\n\n\n\n\n\ngencalc_wan(job::DFJob, min_window_determinator::Real, extra_wan_flags...; kwargs...)\n\nAutomates the generation of wannier calculations based on the job. When a projwfc calculation is present in the job, min_window_determinator will be used to determine the threshold value for including a band in the window based on the projections, otherwise it will be used as the Emin value from which to start counting the number of bands needed for all projections. extra_wan_flags can be any extra flags for the Wannier90 calculation such as write_hr etc.\n\n\n\n\n\n","category":"function"},{"location":"guide/calculations/#Output","page":"Calculations","title":"Output","text":"","category":"section"},{"location":"guide/calculations/","page":"Calculations","title":"Calculations","text":"outputdata\nreadfermi\nreadbands","category":"page"},{"location":"guide/calculations/#DFControl.outputdata","page":"Calculations","title":"DFControl.outputdata","text":"outputdata(calculation::DFCalculation; extra_parse_funcs=[], print=true, overwrite=true)\n\nIf an output file exists for calculation this will parse it and return a Dict with the parsed data. If overwrite=false and calculation.outputdata is not empty, this will be returned instead of reparsing the output file.\n\nextra_parse_funcs should be Vector{Pair{String,Function}}, where the string will be used to match occursin(str, line) for each line of the output file. If this returns true, the function will be called as func(results_dict, line, file). The purpose is to allow for additional parsing that is not implemented, or for temporary non-standard values that are printed while working on the DFT code, e.g. for debugging.\n\nnote: Note\nThis only works for files where not all information is pulled out for yet, e.g. projwfc.x outputs are fully parsed already.\n\nExample (from src/qe/fileio.jl):\n\n\nfunction qe_parse_nat(results, line, f)\n    results[:nat] = parse(Int, split(line)[end])\nend\n\noutputdata(job[\"scf\"], extra_parse_funcs = [\"number of atoms/cell\" => qe_parse_nat])\n\n\n\n\n\nFinds the output files for each of the calculations of a job, and groups all found data into a dictionary.\n\n\n\n\n\n","category":"function"},{"location":"guide/calculations/#DFControl.readfermi","page":"Calculations","title":"DFControl.readfermi","text":"readfermi(calculation::DFCalculation)\n\nParses the outputdata associated with calculation and returns the fermi level if present.\n\nreadfermi(job::DFJob)\n\nFinds the first scf calculation present in the job, reads its outputdata and returns the fermi level if present.\n\n\n\n\n\n","category":"function"},{"location":"guide/calculations/#DFControl.readbands","page":"Calculations","title":"DFControl.readbands","text":"readbands(calculation::DFCalculation)\n\nParses the outputdata associated with calculation and returns the bands if present.\n\nreadbands(job::DFJob)\n\nWill try to find the first bandstructure calculation present in the job with a valid output file, and return the bands if present. If no normal bandstructure calculation is present, it will return the bands produced by a possible nscf calculation if one exists with a valid output file.\n\n\n\n\n\n","category":"function"},{"location":"#DFControl","page":"Home","title":"DFControl","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The goal of DFControl is to alleviate some of the tedious day to day busy-work that material's scientists using DFT  codes encounter. It aids in the creation, execution, monitoring, management, and post-processing of DFT jobs.  The core framework is code-agnostic, however, most of the convenience features are so far only implemented for Quantum-Espresso and Wannier90. ABINIT and ELK support is highly experimental and incomplete.","category":"page"},{"location":"#Philosophy","page":"Home","title":"Philosophy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DFControl is aimed to be user friendly first and foremost, with features being added as time progresses without changing this core value. On the other hand, a core requirement has always been that power users that know all the ins and outs of the codes that they run should be able to have all the control they want without incurring friction from the library. DFControl therefore should never be a barrier to DFT code functionality, just a tool to increase efficiency of its users.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In light of this DFControl is structured to mimic the often adopted strategy of a linear submission script that specifies which input files  are ran with which DFT codes producing which outputs. Everything revolves around the DFJob that holds a collection of DFCalculations which will be ran sequentially in the job's directory, on the job's crystal Structure. A DFJob is therefore identified with a specific directory. Using the script that is created upon saving or submitting a job, a DFJob can be easily reloaded at a later stage to continue the investigation where left off.","category":"page"},{"location":"#Highlighted-features","page":"Home","title":"Highlighted features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Creation and submission of a simple self-consistent-field calculation starting from a structure Cif file in less than 10 lines of code (see the Basic Tutorial])\nSeparation of Structure and DFCalculation so that the same DFCalculations can be copied and used with a different Structure in a new job \nAutomatic validation and conversion of input flags\nTracking of DFJobs for ease of continuation at later times\nEase of calculation generation\nAutomatic plotting of available results using a single command\nInput flag sanity checks\nRudimentary DFJob versioning to never lose previous DFJob's results even if running in the same directory\nFully human readable and transparent DFJob directory structure ","category":"page"},{"location":"guide/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"guide/installation/","page":"Installation","title":"Installation","text":"In case you don't have a working Julia installation yet, first download the Julia binaries and follow the Julia installation instructions. DFControl is tested thoroughly with Julia 1.6, your mileage may vary with older versions.","category":"page"},{"location":"guide/installation/","page":"Installation","title":"Installation","text":"Afterwards you can install DFControl like any other package in Julia. For example run in your Julia REPL terminal:","category":"page"},{"location":"guide/installation/","page":"Installation","title":"Installation","text":"import Pkg\nPkg.add(\"DFControl\")","category":"page"},{"location":"guide/installation/","page":"Installation","title":"Installation","text":"which will install the latest DFControl release. Alternatively (if you like to be fully up to date) install the master branch:","category":"page"},{"location":"guide/installation/","page":"Installation","title":"Installation","text":"import Pkg\nPkg.add(name=\"DFControl\", rev=\"master\")","category":"page"},{"location":"guide/installation/","page":"Installation","title":"Installation","text":"DFControl is continuously tested on Debian, Ubuntu, mac OS and Windows and should work on these operating systems out of the box.","category":"page"},{"location":"guide/installation/","page":"Installation","title":"Installation","text":"After these steps it is highly recommended to go through some additional Configuration.","category":"page"},{"location":"guide/configuration/#Configuration","page":"Configuration","title":"Configuration","text":"","category":"section"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"In order to not always have to respecify where to look for PseudoPotential sets,  they can be set up once and be remembered by DFControl.  This can be done through:","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"using DFControl\n\nsetdefault_pseudodir(:pseudo_set_name1, \"/absolute/path/to/pseudopotential/set/1\")\nsetdefault_pseudodir(:pseudo_set_name2, \"/absolute/path/to/pseudopotential/set/2\")\n\nconfiguredefault_pseudos()","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"This will go through the specified directories and find files that follow the naming convention element.x_y_z.xyz e.g. Si.pbesol-n-kjpaw_psl.0.1.UPF or si.pbesol-n-kjpaw_psl.0.1.UPF.  If multiple are found, all will be stored and the required one can be later specified. See Pseudo Potentials for further usage details.","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"In order to change the pseudos associated with a set name simply:","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"setdefault_pseudodir(:pseudo_set_name1, \"/new/absolute/path/to/pseudopotential/set/1\")\nsetdefault_pseudodir(:pseudo_set_name2, \"/new/absolute/path/to/pseudopotential/set/2\")\n\nconfiguredefault_pseudos()","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"In order to remove a default pseudo set one can run:","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"removedefault_pseudos(:pseudo_set_name)","category":"page"},{"location":"guide/configuration/","page":"Configuration","title":"Configuration","text":"After completing this configuration, it is suggested to look at the (Basic Usage)[@ref] for an introduction to the basic usage of DFControl.","category":"page"}]
}
